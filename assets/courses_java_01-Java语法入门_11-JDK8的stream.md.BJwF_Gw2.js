import{_ as a,o as e,c as t,R as r}from"./chunks/framework.FHZ5yb6k.js";const f=JSON.parse('{"title":"11-Stream流处理","description":"","frontmatter":{"title":"11-Stream流处理","author":"Ray","date":"2020/10/02 21:30","categories":["Java生态"],"tags":["Java","Java基础","JDK","开发环境"]},"headers":[],"relativePath":"courses/java/01-Java语法入门/11-JDK8的stream.md","filePath":"courses/java/01-Java语法入门/11-JDK8的stream.md","lastUpdated":1744847932000}'),o={name:"courses/java/01-Java语法入门/11-JDK8的stream.md"},i=r('<h2 id="jdk8的stream流处理" tabindex="-1"># JDK8的Stream流处理 <a class="header-anchor" href="#jdk8的stream流处理" aria-label="Permalink to &quot;# JDK8的Stream流处理&quot;">​</a></h2><h2 id="stream" tabindex="-1">Stream <a class="header-anchor" href="#stream" aria-label="Permalink to &quot;Stream&quot;">​</a></h2><p>Stream不是<strong>集合元素，他不是数据结构并不保存数据</strong>，他是有关算法和计算的，更像是一个高级版本的<strong>Iterator</strong>。 原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。 Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。 流的构成 当我们使用一个流的时候，通常包括三个基本步骤： 获取一个数据源（source）→ 数据转换→执行操作获取想要的结果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道，如下图所示。 流的操作类型分为两种： Intermediate(中间)：一个流可以后面跟随零个或多个intermediate操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。 Terminal：一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。</p><h3 id="流的使用" tabindex="-1">流的使用 <a class="header-anchor" href="#流的使用" aria-label="Permalink to &quot;流的使用&quot;">​</a></h3><h4 id="创建stream" tabindex="-1">创建Stream <a class="header-anchor" href="#创建stream" aria-label="Permalink to &quot;创建Stream&quot;">​</a></h4><ol><li>Stream.of()</li><li>基于数组或者Collection <ul><li>数组 Arrays.stream(数组);</li><li>Collection 直接调用stream方法</li></ul></li><li>使用其他类的相关方法 Files.lines(Path.get(&quot;path&quot;));</li></ol><h4 id="map" tabindex="-1">map <a class="header-anchor" href="#map" aria-label="Permalink to &quot;map&quot;">​</a></h4><p><strong>把一个stream转换成另一个stream</strong>,其实就是对每一个元素进行运算，映射到另一个新的stream</p><h4 id="filter" tabindex="-1">filter <a class="header-anchor" href="#filter" aria-label="Permalink to &quot;filter&quot;">​</a></h4><p>过滤</p><h4 id="reduce" tabindex="-1">reduce <a class="header-anchor" href="#reduce" aria-label="Permalink to &quot;reduce&quot;">​</a></h4><p>将所有元素聚合成一个结果</p><h4 id="输出集合" tabindex="-1">输出集合 <a class="header-anchor" href="#输出集合" aria-label="Permalink to &quot;输出集合&quot;">​</a></h4><h4 id="其他操作" tabindex="-1">其他操作 <a class="header-anchor" href="#其他操作" aria-label="Permalink to &quot;其他操作&quot;">​</a></h4><h5 id="转换" tabindex="-1">转换 <a class="header-anchor" href="#转换" aria-label="Permalink to &quot;转换&quot;">​</a></h5><h5 id="聚合" tabindex="-1">聚合 <a class="header-anchor" href="#聚合" aria-label="Permalink to &quot;聚合&quot;">​</a></h5><p>reduce map count</p><h5 id="合并" tabindex="-1">合并 <a class="header-anchor" href="#合并" aria-label="Permalink to &quot;合并&quot;">​</a></h5><h5 id="并行" tabindex="-1">并行 <a class="header-anchor" href="#并行" aria-label="Permalink to &quot;并行&quot;">​</a></h5>',19),l=[i];function s(h,n,d,m,c,u){return e(),t("div",null,l)}const p=a(o,[["render",s]]);export{f as __pageData,p as default};
