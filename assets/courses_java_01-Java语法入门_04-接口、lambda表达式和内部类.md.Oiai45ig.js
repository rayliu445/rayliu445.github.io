import{_ as r}from"./chunks/ArticleMetadata.d4_nZKBO.js";import{_ as d,D as g,o as n,c as p,I as o,w as A,k as s,a as i,R as t,b as y,e as c}from"./chunks/framework.FHZ5yb6k.js";import"./chunks/md5.0oexlRJv.js";const M=JSON.parse('{"title":"04-接口、lambda表达式和内部类","description":"","frontmatter":{"title":"04-接口、lambda表达式和内部类","author":"Ray","date":"2020/10/02 21:30","categories":["Java生态"],"tags":["Java","Java基础","JDK","开发环境"]},"headers":[],"relativePath":"courses/java/01-Java语法入门/04-接口、lambda表达式和内部类.md","filePath":"courses/java/01-Java语法入门/04-接口、lambda表达式和内部类.md","lastUpdated":1745473205000}'),D={name:"courses/java/01-Java语法入门/04-接口、lambda表达式和内部类.md"},C=s("h1",{id:"接口、lambda表达式和内部类",tabindex:"-1"},[i("接口、lambda表达式和内部类 "),s("a",{class:"header-anchor",href:"#接口、lambda表达式和内部类","aria-label":'Permalink to "接口、lambda表达式和内部类"'},"​")],-1),B=t(`<h2 id="接口" tabindex="-1">接口 <a class="header-anchor" href="#接口" aria-label="Permalink to &quot;接口&quot;">​</a></h2><p>接口是一种技术，<strong>用来描述类应该做什么，但是不指定如何做</strong>。一个类可以实现一个或者多个接口。然后本章节介绍lambda表达式，再讨论内部类(定义在其他类的内部，可以访问外部类的字段)，最后学习反射机制。</p><h3 id="接口的概念" tabindex="-1">接口的概念 <a class="header-anchor" href="#接口的概念" aria-label="Permalink to &quot;接口的概念&quot;">​</a></h3><p>接口不是类，而是希望实现它的所要完成的一组需求。 例如Comparable接口的代码</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> Comparable</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> comparableToS</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(T </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">other</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p><strong>接口中的方法默认使用public</strong> 在这里定义接口的时候使用了泛型，我们知道泛型即泛型数组列表，是让<strong>编译器来帮我们检验我们数组列表中存放的类型是否一致</strong>。 List&lt;TreeNode&gt; list=new LinnkedList&lt;&gt;(); 菱形语法 Comparable&lt;T&gt;即是代表将来实现接口时，<strong>开发者能够将原始参数类型转化为适当的类型</strong>。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> Employee</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> implents Comparable&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Employee</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">	//由此可以看出我们将泛型的T-原始参数类型转化为我们想要的类型</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> comparableTo</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Employee </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">other</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Double.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">compareTo</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(salary,other.salary);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>实现接口时使用public，否则编译器会视为包权限。 注:正常情况下x.equals()y时x.compareTo(y)就应当为0，有一个类例外，BigDecimal,在比较1.0和1.00时comparable就会出现负值。</p><h5 id="常用api" tabindex="-1">常用API <a class="header-anchor" href="#常用api" aria-label="Permalink to &quot;常用API&quot;">​</a></h5><p>java.lang.Comparable&lt;T&gt; int comparableTo(T other) 将<strong>这个对象与other进行比较</strong> java.util.Arrays static void sort(Object[] a) 对数组中<strong>a中的元素进行排序</strong>。要求<strong>数组中的元素必须属于实现了Comparable接口的类</strong>，元素之间也要能够进行比较。 java.lang.Integer static int compare(int x ,int y)<strong>如果x&lt;y返回一个负整数;如果x和y相等，则返回0</strong>;否则返回一个正整数。 java.lang.Double static int compare(double x,double y)<strong>如果xy返回一个负整数</strong>;如果x和y相等则返回0;否则返回一个正整数。 注:sgn(x.compareTo(y))=-sgn(y.compare(x))，如果前者有异常的话，那么后者也应该出现异常。这里的“sgn”可以理解为一种规则，即如果xy的话，那么结果就是1。 如果Manager扩展了Employee,Employee实现的是Comparable&lt;Employee&gt;,而在Manager中实现的是Comparble&lt;Manager&gt;,Employee ep=new Employee(); Manager manager =new Manager();如果是ep.compareTo(manager)，那么没什么问题，因为经理也是员工。但是，如果manager.compareTo(ep),那么就会出现ClassCastException。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> Manager</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> Employtee</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">	public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> compareTo</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Employee </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">other</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">		Manager</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> m</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Manager) other; </span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">//很明显，这里是向下转型，会出问题</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><h3 id="接口的属性" tabindex="-1">接口的属性 <a class="header-anchor" href="#接口的属性" aria-label="Permalink to &quot;接口的属性&quot;">​</a></h3><p>接口不能被实例化 <strong>可以使用instanceof来检验一个对象是否实现了某个接口</strong>,如下</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(anyObject </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">instanceof</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Compable){...}</span></span></code></pre></div><p>和继承一样，接口也存在链,也就是说一个接口可以扩展另一个接口，使用extends关键字，被称为<strong>接口链</strong>。 接口中不允许有实例字段，但是可以定义常量。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> Powered</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> Mobeable</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">	double</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> SPEED_LIMIT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">95</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>接口中的字段总是public static final</p><h3 id="接口与抽象类" tabindex="-1">接口与抽象类 <a class="header-anchor" href="#接口与抽象类" aria-label="Permalink to &quot;接口与抽象类&quot;">​</a></h3><p>在这里，我们提出了一个问题，既然抽行类也有定义需求的功能，为什么还要这么麻烦地引入接口呢？ 这是因为类在设计时就只允许只能一个一个类，而一个类却可以实现多个接口。 注：C++设计者允许一个类有多个超类，但是Java不支持多重继承。</p><h4 id="共同点" tabindex="-1">共同点 <a class="header-anchor" href="#共同点" aria-label="Permalink to &quot;共同点&quot;">​</a></h4><p>1.都不能被实例化 2.都可以包含抽象方法 3.都可以有默认实现的方法</p><h4 id="区别" tabindex="-1">区别 <a class="header-anchor" href="#区别" aria-label="Permalink to &quot;区别&quot;">​</a></h4><p>1.接口规范行为,抽象类强调的是所属关系 2.一个类只能继承一个类,但是可以实现多个接口 3.抽象类的成员变量默认default,可在子类中被重新定义,也可以被重新赋值。</p><h3 id="静态和私有方法" tabindex="-1">静态和私有方法 <a class="header-anchor" href="#静态和私有方法" aria-label="Permalink to &quot;静态和私有方法&quot;">​</a></h3><p>java8中允许在接口中增加静态方法，只是一般将静态方法放在伴随类中，所以我们<strong>经常会在标准库中见到成对出现的接口和实用工具类</strong>。 Java9中接口中方法可以是private，<strong>private可以是静态或者实例方法，但是只能在接口本身中使用，用法有限，一般作其他方法的辅助方法</strong>。</p><h3 id="默认方法" tabindex="-1">默认方法 <a class="header-anchor" href="#默认方法" aria-label="Permalink to &quot;默认方法&quot;">​</a></h3><p>可以为接口中的方法提供一个默认实现，使用default修饰。例如</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> Comparable</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">E</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">	default</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> compareTo</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(T </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">other</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">		return</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">//默认情况</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>大多数情况下没有用处，因为Compable的具体实现会覆盖掉这个方法</p><p>迭代器</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> Iterator</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">E</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">	boolean</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> hasNext</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">	E </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">	default</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> remove</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">		throw</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> UnsupportededOperationException</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;remove&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>如果实现一个迭代器，那么必须提供hasNext()和next()方法。<strong>这些方法没有默认实现-取决于你的数据结构</strong> 默认方法的一个重要作用就是“接口演化”，很久之前定义了一个类， public class Bag implements Collection 后来接口中增加了一个stream的方法，<strong>由于Bag类没有实现stream方法，那么Bag类将无法编译(无法保证“源代码兼容”)</strong>。 假设不编译这个类，而是<strong>只使用原来的一个包含这个类的jar文件,这个类可以正常加载</strong>，尽管没有新方法。程序仍然可以正常构造Bag实例，但是如果调用实例方法sream()，那么就会出现AbstactMethodError。 如果来使用了default的话，那么Bag类就能通过编译，另外，<strong>如果重新编译而直接加载这个类的话并且在一个实力上使用sream方法，实际上调用的的是Collection.stream()</strong>。</p><h3 id="默认方法解决冲突" tabindex="-1">默认方法解决冲突 <a class="header-anchor" href="#默认方法解决冲突" aria-label="Permalink to &quot;默认方法解决冲突&quot;">​</a></h3><p>如果两个接口定义了形同的方法，或者一个超类和一个接口定义了相同的方法。 1.超类优先。 2.如果两个接口相互冲突，那么就要覆盖这个方法来解决冲突(二者择其一)。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">	default</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getName</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">		return</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &quot; &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">	};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> Named</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    default</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Strting </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getName</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        	return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> getClass</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;_&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">+</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">hashCode</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>在子类中进行覆盖</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> Student</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;">Named</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">	public</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getName</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">		return</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Person.super.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getName</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><h3 id="接口与回调" tabindex="-1">接口与回调 <a class="header-anchor" href="#接口与回调" aria-label="Permalink to &quot;接口与回调&quot;">​</a></h3><p><strong>回调(callback)是一种常见的程序设计模式</strong>。在这种模式中，你可以指定某个特定事件发生后执行的操作。例如，点击菜单选项之后完成的某个特定动作。</p><p>在java.swing包中有一个Timer类，非常有用。</p><p>构造定时器时，需要设置时间间隔，并指定需要干什么。</p><p>在Java中，我们可以向定时器中传入一个对象，因为对象携带的信息要比单单一个参数更多，从代码中可以看出传递的是一个监听器对象，这个监听器对象干了什么事儿呢，它打印了语句，同时执行了beep()，这也是面向对象的优势。</p><p>我们要知道<strong>定时器要调用哪个方法，并要求传递的对象所属的类实现了java.awt.event包下的ActionListener接口</strong>。</p><p>顺便一提，new Timer(1000 ,listener);是构造器，而构造完成的是定时器。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> ActionListener</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">	void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> acitonPerformed</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Action </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">Event</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>当到达指定的时间间隔时,定时器就调用actionPerformed方法。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> TimePrinter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> AcitonListerner</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">	public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> acitionPerformed</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(ActionEvent </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">		System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;At the tone,the time is...&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Instance.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">ofEpochMilli</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(event.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getWhen</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">()));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">		Toolkit.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getDefaultToolkit</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">beep</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>Timer构造器传入的参数第一个是时间间隔，第二个是监听器对象</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Timeprinter</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> listener</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> Timeprinter</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Timer</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> timer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> Timer</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> ,listener);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">timer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">start</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span></code></pre></div><p>通过start()来启动定时器</p><h3 id="comparator接口" tabindex="-1">Comparator接口 <a class="header-anchor" href="#comparator接口" aria-label="Permalink to &quot;Comparator接口&quot;">​</a></h3><p>之前我们已经了解了如何对一个对象数组进行排序，前提是对象数组中的元素(对象)需要实现Comparable接口，这样才可以将两个对象进行比较。例如，String.compareTo方法可以按字典顺序比较字符串，这是由于String类实现了Comparable&lt;String&gt;。 现在，我们希望能够按字符串长度进行排序，显然我们无法对String类进行修改。 如何处理这种情况呢，在Arrays.sort方法中还有第二个版本，有一个数组和一个<strong>比较器</strong>(comparator)作为参数，比较器是实现了Comparator接口的类的实例。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> Comparator</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">	int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> compare</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(T </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">first</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> ,T </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">second</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> LengthComparator</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> Compararot</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> comapre</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(String </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">first</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,String </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">second</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> first.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">second.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> comp</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> LengthComparetor</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(comp.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">compare</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(words[i],words[j]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">)...</span></span></code></pre></div><p>将这个与words[i].comapreTo(words[j])进行比较，可以看出，这个compare是在比较器上调用。 要对一个数组进行排序，要为Arrays.sort()方法传入一个LengthComparator对象。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> friends</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> String</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;Peter&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;Mary&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;Paul&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Arrays.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">sort</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(friends,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> LengthComparator</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">());</span></span></code></pre></div><p><strong>理解了这个例子我们学习lamda表达式才能更加容易</strong></p><h3 id="对象克隆cloneable" tabindex="-1">对象克隆Cloneable <a class="header-anchor" href="#对象克隆cloneable" aria-label="Permalink to &quot;对象克隆Cloneable&quot;">​</a></h3><p>Cloneable接口，用的比较少，但是这里的技术性很强。 为了解决什么问题，首先我们所学过创建一个包含对象引用的变量的副本，原对象和副本都是同一个对象的引用。如下</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Employee</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> original</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> Employe</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;jack&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">22</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">4000</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Employee</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> copy</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">original;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">copy.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">raiseSalary</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span></code></pre></div><p>我们希望有一个对象的副本但不影响对象的后续状态</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Employee</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> copy</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">original.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">clone</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">copy.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">raiseSalary</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span></code></pre></div><p>从下面这张图，我们直观地理解克隆的过程。</p><p><img src="https://gitee.com/aryangzhu/picture/raw/master/%E5%85%8B%E9%9A%86.jpg" alt=""></p><pre><code>通常说的克隆是“浅拷贝“即对象中引用的子对象并不会克隆，而会直接引用。这个时候，我们考虑的应当是子对象是否是可变的，如果子对象是final的那么就可以确保安全性，或者子对象没有修改器或者被引用的可能，那么同样也是安全的。例如，String是不可变的，共享就是安全的。
但是，通常子对象都是可变的，图中的hireDay是Date类的对象，所以要克隆的话需要重新定义clone方法来进行深拷贝。
</code></pre><p>对于每一个类，要确定 1.默认的clone方法是否够用 2.是否可以在可变的子对象上调用clone()方法来修补默认的clone()方法。 3.是否不应该使用克隆。 如果前两项成立 1.实现Cloneable接口 2.重新定义(覆盖掉Object类的方法)clone方法，并指定public 访问修饰符。<strong>注意：</strong> 1.<strong>protected限制是同一个包下的类可以访问超类的字段</strong>，所以，Date类型的hireDay肯定无法直接由Employee来clone()，引用对象需要单独复制。 2.Cloneable是一个标记接口，不包含任何方法，但是可以使用instanceof关键字来检查。</p><h2 id="lamda表达式" tabindex="-1">lamda表达式 <a class="header-anchor" href="#lamda表达式" aria-label="Permalink to &quot;lamda表达式&quot;">​</a></h2><h3 id="为什么引入lamba表达式" tabindex="-1">为什么引入lamba表达式 <a class="header-anchor" href="#为什么引入lamba表达式" aria-label="Permalink to &quot;为什么引入lamba表达式&quot;">​</a></h3><p><strong>lamba表达式是一个可传递的代码块</strong> 例如之前的TimerPrinter，可以构造一个实例提交到Timer对象。 再或者想要自己定制一个比较器，可以向数组传递一个Comparator对象 上面两者的共同特征是将一个代码块传递到到某个对象(定时器，Arrays的sort方法)</p><h3 id="lamba表达式的语法" tabindex="-1">lamba表达式的语法 <a class="header-anchor" href="#lamba表达式的语法" aria-label="Permalink to &quot;lamba表达式的语法&quot;">​</a></h3><p>用排序来说明，first.length()-second.length()使我们的主要任务。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(String first,String second)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">	-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">first.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">second.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">()</span></span></code></pre></div><p>为什么被称为lamba，来源也很有趣 <strong>表达形式</strong>:参数、箭头(-&gt;)以及一个表达式</p><h4 id="几种常见的用法" tabindex="-1">几种常见的用法 <a class="header-anchor" href="#几种常见的用法" aria-label="Permalink to &quot;几种常见的用法&quot;">​</a></h4><p>1.在{}中编写程序,如果需要运行的程序无法通过一个表达式完成，则应该放在{}中</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(String first,String second)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">	if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(first.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">second.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">()) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (first.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">lenght</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">second.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">()) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> return</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>2.如果表达式没有参数，也要保留空括号，就像无参数的函数一样</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">		System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(i);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>3.如果可以推导出参数的值，那么就可以忽略</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Comparator</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&gt; </span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">comp</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(first,second)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">first.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">second.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span></code></pre></div><p>这里编译器能够推导出来first和second都是String字符串类型的。</p><p>4.如果只有一个参数，而且这个参数是可以推导出来的，那么可以省略小括号。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Action</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> listener</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">event</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;At the tone,the time is...&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">+</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">                       Instant.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">ofEpochMilli</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(event.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getWhen</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">()));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><h4 id="函数式接口" tabindex="-1">函数式接口 <a class="header-anchor" href="#函数式接口" aria-label="Permalink to &quot;函数式接口&quot;">​</a></h4><p>Java中有许多接口中都有封装代码块，和lamba表达式兼容，接口中必须有且仅有一个<strong>抽象方法</strong>，并且在使用时可转换为lamba表达式的接口被称为函数式接口(Comparator和ActionListener)。</p><p>例如，之前的Arrays.sort方法</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Arrays.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">sort</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(friends,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> LengthComparator</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">());</span></span></code></pre></div><p>Comparator接口转化为lamba表达式</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Arrays.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">sort</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(friends,( first, second)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">first.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">second.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">()); </span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">//由于sort(Stirng str,Comparator&lt;String&gt;)会进行判断，所以前面的小括号中就不用写first和second的类</span></span></code></pre></div><p>在sort底层，将接受一个实现了Comparator&lt;String&gt;的类的对象，并在这个对象上调用compare方法执行lamba表达式主体。</p><p>再来看看ActionListener接口</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> TimePrinter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> AcitonListerner</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">	public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> acitionPerformed</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(ActionEvent </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">		System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;At the tone,the time is...&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Instance.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">ofEpochMilli</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(event.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getWhen</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">()));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">		Toolkit.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getDefaultToolkit</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">beep</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Timeprinter</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> listener</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> Timeprinter</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Timer</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> timer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> Timer</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> ,listener);</span></span></code></pre></div><p>我们将其转化为lamba表达式</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Timer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> Timer</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,event</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    	System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;At the tone,the time is...&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Instance.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">ofEpochMilli</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(event.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getWhen</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">()));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">		Toolkit.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getDefaultToolkit</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">beep</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">});</span></span></code></pre></div><p><strong>lambda表达式最大的用途就是函数式接口,而且lambda表达式是一个函数而不是一个对象</strong></p><h5 id="java-api在java-util-function包中定义的通用的函数式接口" tabindex="-1">Java API在java.util.function包中定义的通用的函数式接口 <a class="header-anchor" href="#java-api在java-util-function包中定义的通用的函数式接口" aria-label="Permalink to &quot;Java API在java.util.function包中定义的通用的函数式接口&quot;">​</a></h5><h6 id="predicate接口" tabindex="-1">Predicate接口 <a class="header-anchor" href="#predicate接口" aria-label="Permalink to &quot;Predicate接口&quot;">​</a></h6><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> Predicate</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">	boolean</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(T </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">t</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>ArrayList类有一个removeIf方法，它的参数就是一个Predicate。这个接口专门用来传递lambda表达式。例如删除数组列表中的所有空值。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">removeIf</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(e</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">e</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span></code></pre></div><h3 id="方法引用" tabindex="-1">方法引用 <a class="header-anchor" href="#方法引用" aria-label="Permalink to &quot;方法引用&quot;">​</a></h3><p>来看之前的一个例子</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Timer</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> timer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> Timer</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,event</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(event));</span></span></code></pre></div><p>直接将println()传递到Timer构造器</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Timer</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> timer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> Timer</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,System.out</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">::</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">println);</span></span></code></pre></div><p>表达式System.out::println是一个<strong>方法引用(method reference)</strong>,<strong>它指示编译器生成一个函数式接口的实例，并且覆盖掉接口中的方法</strong>，在上面的代码中，会<strong>生成一个ActionListener的实例，并且覆盖掉actionPerformed(ActionEvent e)方法</strong>，调用System.out.println(e);</p><p><strong>方法引用也不是一个对象</strong>,但是为一个类型为函数式接口的变量赋值时会生成一个对象。</p><p>PrintStream类(System.out就是PrintStream类的一个实例)中有10个重载的println方法。编译器需要根据上下文确定使用哪一个方法。在上面的例子中，方法引用System.out.println必须转换为一个包含以下方法的AcitonListener实例:</p><p>void actionPerformed(ActionEvent e)</p><p>这样会从10个重载的printl方法中选出println(Object x)方法，因为Object与ActionEvent最匹配。调用actionPerformed方法时，就会打印出这个事件对象。</p><p>假设，将同样的方法引用赋至一个不同的函数式接口:</p><p>Runable task=System.out::println();</p><p>这个Runable函数式接口有一个无参数的抽象方法:</p><p>void run()</p><p>这里会选择无参数的prinlnt()方法，调用task.run()方法会向System.out打印一个空行。</p><h4 id="使用-运算符的三种情况" tabindex="-1">使用::运算符的三种情况 <a class="header-anchor" href="#使用-运算符的三种情况" aria-label="Permalink to &quot;使用::运算符的三种情况&quot;">​</a></h4><h5 id="_1-object-instancemethod" tabindex="-1">1.object::instanceMethod <a class="header-anchor" href="#_1-object-instancemethod" aria-label="Permalink to &quot;1.object::instanceMethod&quot;">​</a></h5><p>对象::实例方法，相当于向方法传递参数的lambda表达式，对于System.out:println,对象是System.out,等价于x-&gt;System.out.println(x)</p><h5 id="_2-class-instancemethod" tabindex="-1">2.Class::instanceMethod <a class="header-anchor" href="#_2-class-instancemethod" aria-label="Permalink to &quot;2.Class::instanceMethod&quot;">​</a></h5><p>类::实例方法，::之前的参数会成为方法的隐式参数。例如，String::compareToIgnoreCase等同于(x,y)-&gt;x.compareToIgnoreCase(y)</p><h5 id="_3-class-staticmethod" tabindex="-1">3.Class:StaticMethod <a class="header-anchor" href="#_3-class-staticmethod" aria-label="Permalink to &quot;3.Class:StaticMethod&quot;">​</a></h5><p>所有参数都传递到静态方法，例如Math::pow等价于(x,y)-&gt;Math.pow(x,y)</p><h3 id="引用构造" tabindex="-1">引用构造 <a class="header-anchor" href="#引用构造" aria-label="Permalink to &quot;引用构造&quot;">​</a></h3><h3 id="变量的作用域" tabindex="-1">变量的作用域 <a class="header-anchor" href="#变量的作用域" aria-label="Permalink to &quot;变量的作用域&quot;">​</a></h3><p>通过代码更加直观</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> repeatMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(String text,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> delay){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    ActionListener</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> listener</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">event</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(text);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">		Toolkit.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getDefaultToolkit</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">beep</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> Timer</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(delay,listener.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">start</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">());</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>方法调用reapeatMessage(&quot;Hello&quot;,1000);</p><p>从上面的代码中我们可以知道text并不是lambda表达式中的值，而且lambda表达式的值有可能在repeatMessage方法返回参数许久之后才执行，如何保存text值？</p><p>lambda表达式一共有三个部分</p><p>1.一个代码块</p><p>2.参数</p><p>3.<strong>自由变量的值</strong>，就是在lambda表达式的代码块中没有出现过的值。</p><p>lambda表达式的数据结构必须保存自由变量的值，在上面的例子中就是“Hello”,这里称之为lambda表达式对于自由变量的“捕获”。</p><p>我们来看具体的实现细节，首先，<strong>自由变量只能引用值而不能修改值</strong></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> repeatMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> start,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> delay){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    ActionListener</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> listener</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">event</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(start</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">//error can&#39;t captured</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">		Toolkit.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getDefaultToolkit</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">beep</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>这是因为在并发执行的环境下会出现安全性问题。</p><p><strong>在lambda表达式内部引用的值如果在外部可以更改也是不合法的</strong></p><div class="language-Java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> repeatMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(String text,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> delay){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    	ActionListener</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> listener</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">event</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">       		System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot; &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">text); </span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">//error can&#39;t captured</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">			Toolkit.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getDefaultToolkit</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">beep</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><h3 id="处理lambda表达式" tabindex="-1">处理lambda表达式 <a class="header-anchor" href="#处理lambda表达式" aria-label="Permalink to &quot;处理lambda表达式&quot;">​</a></h3><p>使用lambda表达式的重点是<strong>延迟执行(deferred execution)</strong></p><p>要延迟执行的情况可能有以下:</p><p>1.在一个单独的线程中执行代码</p><p>2.多次运行代码</p><p>3.在算法的适当位置使用(排序时的比较)</p><p>4.发生某个事件时使用(点击了按钮)</p><p>5.只在必要时才运行的代码</p><p>假设有一种情况是我们需要循环执行一个操作</p><p>repeat(10,()-&gt;System.out.println(&quot;Hello world!&quot;));</p><p>要执行这个lambda表达式就要有一个函数式接口，书上使用的是Runnable接口。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> repeat</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> n,Runnable action){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">n;i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        action.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">run</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>我们知道Runnable是实现多线程操作时需要类实现的一个接口,既然启动了别的线程说明只有action.run()被调用时才会执行这个lambda表达式的主体。</p><p>为了让例子复杂一些，我们希望告诉它在哪次迭代中需要执行这个动作,需要选择一个合适的函数式接口。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> IntConsumer</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> accept</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;"> value</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>重写一下这个repeat方法</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> repeat</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> n,intConsumer action){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">n;i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">)action.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">accept</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(i);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>转换为lambda表达式</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">repeat</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;CountDown&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">9</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">i)));</span></span></code></pre></div><h3 id="再谈comparator" tabindex="-1">再谈Comparator <a class="header-anchor" href="#再谈comparator" aria-label="Permalink to &quot;再谈Comparator&quot;">​</a></h3><p>Comparator接口中包含许多<strong>静态方法</strong>来创建比较器。这些方法可以用lambda表达式或方法引用。</p><p>静态comparing方法是一个“键提取器”函数，<strong>它将类型T映射为一个可比较的类型</strong>(如String)。</p><p>对要比较的对象应用这个函数，然后对<strong>返回的键完成排序</strong>。</p><p>例如，Arrays.sort(people,Comparator.comparing(Person::getName));</p><p>根据名字来排序,与手动实现Comparator相比较，代码更加直观。</p><p>也可以将比较器与thenComparing方法连接起来，来处理结果相同的情况，就是当前一个比较结果一致的时候在继续用别的条件进行比较。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Arrays.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">sort</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(people,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">            Comparator.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">comparing</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">::</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">getName)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">           .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">thenComparing</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">::</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">getFirstName));</span></span></code></pre></div><p>很多方法还有变体形式,可以为comparing和thenComparing方法提取的键指定与一个比较器，就像套娃一样，例如，根据姓名长度排序，姓名&amp;长度</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Arrays.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">sort</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(people,Comparator.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">comparing</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">::</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">getName,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">       (s,t)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Integer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">compare</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(s.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">().t.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">())));</span></span></code></pre></div><p>另外的comparing和thenComparing方法的变体，可以避免int、long或者double值的装箱,也就是我们前面按长度比较时需要装箱(个人猜测)。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Arrays.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">sort</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(people,Comparator.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">comparing</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(p</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">p.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getName</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">()));</span></span></code></pre></div><p>最后，来看一下这个究极复杂的代码</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Arrays.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">sort</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(people,</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">comparing</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">::</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">getMiddleName,</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">nullFirst</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">naturlOrder</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">())));</span></span></code></pre></div><p>尝试理解一下，如果中名为空,那么getMiddleName()返回的就是null,这时我们使用nullFirst()适配器来增加条件使用比较器不会抛出异常。nullFirst()方法需要一个字符串比较器，而naturalOrder()可以为任何实现了Comparator的类建立一个比较器。注意:naturalOrder()的类型可以导出，即Compator&lt;String&gt;naturalOrder()。</p><h2 id="内部类" tabindex="-1">内部类 <a class="header-anchor" href="#内部类" aria-label="Permalink to &quot;内部类&quot;">​</a></h2><p>内部类就是<strong>定义在其他类中的类</strong>。</p><h3 id="为什么使用内部类" tabindex="-1">为什么使用内部类？ <a class="header-anchor" href="#为什么使用内部类" aria-label="Permalink to &quot;为什么使用内部类？&quot;">​</a></h3><p>1.内部类可以对同一个包中的其他类隐藏(也就是说需要在内部完成一些工作而不想被外部访问)。</p><p>2.内部类方法可以访问定义在这个类的作用域中的类，包括原有的私有方法。</p><h3 id="使用内部类访问对象状态" tabindex="-1">使用内部类访问对象状态 <a class="header-anchor" href="#使用内部类访问对象状态" aria-label="Permalink to &quot;使用内部类访问对象状态&quot;">​</a></h3><p>与C++相比，Java内部类的对象会有一个隐式的引用，指向实例化这个对象的外部类对象。通过这个指针，它可以访问外部类的全部状态。</p><p>书上的例子是重构了TimerTest，抽象出一个TalkingClock，语音时钟，需要两个参数，发出通知的间隔和开关铃声的标志。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> TalkingClock</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> interval;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> beep;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> TalkingClock</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;"> interval</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">boolean</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;"> beep</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){...}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> start</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(){...}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> TimerPrinter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> ActionListener</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        ....</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>虽然TimerPrinter位于TalkingClock的内部，但是并不意味着每个TalkingClock对象都有TimerPrinter实例字段。TimerPrinter是在TalkingClock的方法中构造的(也就是说需要用到这个类的对象时才会构造，听起来像是废话)。</p><p>actionpPerformed方法在发出铃声之前会检查beep标志。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> TimerPrinter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> ActionListener</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> acitonPerformed</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Action </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;At the thone the time is&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">+</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        Instant.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">ofEpochMilli</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(event.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getWhen</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">()));</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(beep){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">            Toolkit.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getDefaultToolkit</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">beep</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>从代码中可以看出TimerPrinter中并没有beep的实例字段，但是却可以访问TalkingClock中的beep。说明内部类的对象总有一个隐式引用，可以访问外部类对象。</p><p>我们将外围类称为outer,上面的代码可以等价为</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(outer.beep){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">            Toolkit.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getDefaultToolkit</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">beep</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        }</span></span></code></pre></div><p><strong>外围类的引用由构造器设置</strong>。编译器会修改内部类的构造器，添加当前外围类的参数。</p><p>TimerPrinter中没有构造器，所以编译器会默认生成一个无参的构造器(???书上的这段话让我很迷惑,既然无参那么clock算什么)。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> TimerPrinter</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(TalkingClock clock){</span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">//auto generated code</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    outer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">clock;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>outer并不是Java中的关键字，只是为了方便我们理解。</p><p>在start方法中构造TimerPrinter之后，由于之前生成了内部类的构造器，这时会将当前与语音时钟的this引用传入TimerPrinter的构造器中。</p><h3 id="内部类的特殊语法规则" tabindex="-1">内部类的特殊语法规则 <a class="header-anchor" href="#内部类的特殊语法规则" aria-label="Permalink to &quot;内部类的特殊语法规则&quot;">​</a></h3><h4 id="_1-outerclass-this" tabindex="-1">1.OuterClass.this <a class="header-anchor" href="#_1-outerclass-this" aria-label="Permalink to &quot;1.OuterClass.this&quot;">​</a></h4><p>这是正规语法，例如</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Talking.this.beep)...</span></span></code></pre></div><h4 id="_2-outerobject-new-innerclass-construction-parameters" tabindex="-1">2.outerObject.new innerClass(construction parameters) <a class="header-anchor" href="#_2-outerobject-new-innerclass-construction-parameters" aria-label="Permalink to &quot;2.outerObject.new innerClass(construction parameters)&quot;">​</a></h4><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">ActionListener</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> listener</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> TimePrinter</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span></code></pre></div><p>假设IimePrinter是公共内部类，对于任意的语音始终都可以构造TimePrinter</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">TalkingClock</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> jabber</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> TalkingClock</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">TalkingClock</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">TimePrinter</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> timer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">jabber.</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> TimerPrinter</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span></code></pre></div><h4 id="_3-几个注意的点" tabindex="-1">3.几个注意的点 <a class="header-anchor" href="#_3-几个注意的点" aria-label="Permalink to &quot;3.几个注意的点&quot;">​</a></h4><h5 id="_1-外围类的作用域之外调用内部类" tabindex="-1">1.外围类的作用域之外调用内部类 <a class="header-anchor" href="#_1-外围类的作用域之外调用内部类" aria-label="Permalink to &quot;1.外围类的作用域之外调用内部类&quot;">​</a></h5><p>outerClass.innerClass</p><h5 id="_2-内部类中的静态字段都必须是final-并初始化为一个编译时常量" tabindex="-1">2.内部类中的静态字段都必须是final,并初始化为一个编译时常量 <a class="header-anchor" href="#_2-内部类中的静态字段都必须是final-并初始化为一个编译时常量" aria-label="Permalink to &quot;2.内部类中的静态字段都必须是final,并初始化为一个编译时常量&quot;">​</a></h5><p>编译时常量指的是程序在<strong>编译时就能确定常量的具体指与之对应的是运行时常量</strong>，运行时常量是程序运行时才能确定的值，例如</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> final</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;     </span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">//编译时常量</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> final</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> d</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;   </span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">//编译时常量 </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> final</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> d</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;   </span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">//编译时常量 </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> final</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> String</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> str4</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &quot;static str&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;  </span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">//编译时常量 </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> final</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> double</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> e</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">random</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">//运行时常量</span></span></code></pre></div><h5 id="_3-内部类中不允许有static方法" tabindex="-1">3.内部类中不允许有static方法 <a class="header-anchor" href="#_3-内部类中不允许有static方法" aria-label="Permalink to &quot;3.内部类中不允许有static方法&quot;">​</a></h5><h3 id="内部类是否有用、必要和安全" tabindex="-1">内部类是否有用、必要和安全 <a class="header-anchor" href="#内部类是否有用、必要和安全" aria-label="Permalink to &quot;内部类是否有用、必要和安全&quot;">​</a></h3><p>内部类是一个<strong>编译器现象</strong>,与虚拟机无关。编译器将会把内部类转换为常规的类文件，用$分隔外部类名与内部类名，而虚拟机则对此一无所知。</p><p>例如，TalkingClock类内部的TimePrinter类将被转换成类文件TalkingClock$TimePrinter.class。</p><p><img src="https://gitee.com/aryangzhu/picture/raw/master/java/%E5%86%85%E9%83%A8%E7%B1%BB%E6%B5%8B%E8%AF%95.png" alt=""></p><p>可以看到，<strong>编译器中生成了一个额外的实例字段this$0</strong>,对应外围类的引用(名字this$0是编译器合成的，在你自己编写的代码中不能引用这个字段。)同时，构造器中也有TalkingClock参数。</p><p>能不能自己动手实现编译器的转换？假设我们将TimePrinter放在TalkingClock的外部，在构造TimePrinter对象的时候，传入它的对象的this指针。</p><p>肯定是有问题的，因为内部类可以访问外部类的私有字段，但是如果实在类的外面的话，那么就不能访问私有字段beep。</p><p>那么问题来了，内部类是如何得到超越自身类的访问权限的呢？</p><p><img src="https://gitee.com/aryangzhu/picture/raw/master/java/TalkingClock.png" alt=""></p><p>编译器在外围类添加了静态方法access$000，将返回作为参数传递的那个对象的beep字段。</p><p>if(beep)实际上会产生以下调用</p><p>if(TalkingClock.access$000(outer))</p><p>这里会有安全性问题，因为任何人都可以通过access$000方法来访问外部类的私有字段beep。黑客可以使用16进制编辑器创建一个类，再通过虚拟机指令调用那个方法。</p><p>下面，我们来描述一下编译器如何构造私有内部类。</p><p>假设将一个TimePrinter转换为一个私有内部类。在虚拟机中不存在私有类，因此编译器会生成一个具有包可见性(default默认)的类，其中有一个私有构造器‘</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">private</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> TalkingClock$TimePrinter</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(TalkingClock)</span></span></code></pre></div><p>由于是私有的所以没有人可以调用这个构造器，因此，还有第二包可见的构造器:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">TalkingClock$TimePrinter</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Talking Clock,TalkingClock$1)</span></span></code></pre></div><p>这个构造器将会调用第一个构造器。合成TalkingClock$1类只是为了将这个构造器与其他构造器区分开。</p><p>我们在start方法中，有</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> listener</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> TimePrinter</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span></code></pre></div><p>将会转换为</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> TalkingClock$TimePrinter</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span></code></pre></div><h3 id="内部局部类" tabindex="-1">内部局部类 <a class="header-anchor" href="#内部局部类" aria-label="Permalink to &quot;内部局部类&quot;">​</a></h3><p>局部常见的就是在方法中定义，TimePrinter只在start()方法中出现了一次，所以遇到这种情况时，可以在一个方法中<strong>局部地定义这个类</strong>。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> start</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">	class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> TimerPrinter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> ActionListener</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    	public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> acitonPerformed</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Action </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;At the thone the time is&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">+</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        Instant.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">ofEpochMilli</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(event.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getWhen</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">()));</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(beep){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">            Toolkit.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getDefaultToolkit</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">beep</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">	}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> listener</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> TimePrinter</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>声明局部类时不能有访问说明符(即public或者private)。局部类的作用域被限定在局部类所在的块中。</p><p>优势:完全对外隐藏，除了start方法之外没有任何方法知道TimePrinter类的存在。</p><h3 id="由外部方法访问变量" tabindex="-1">由外部方法访问变量 <a class="header-anchor" href="#由外部方法访问变量" aria-label="Permalink to &quot;由外部方法访问变量&quot;">​</a></h3><p>与其他内部类相比，局部类不但能够访问外部类的字段，还可以访问局部变量！不过，那些局部变量必须是<strong>事实最终变量</strong>(effectively final),就是说一旦赋值就不能更改。个人理解和final是有区别的，final是不能指向别的引用，对象本身是可以进行修改。</p><p>下面的代码将原本在构造器中参数interval和beep放在start方法中。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> vodi </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">start</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> interval,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> beep){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> TimerPrinter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> ActionListener</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    	public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> acitonPerformed</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Action </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;At the thone the time is&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">+</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        Instant.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">ofEpochMilli</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(event.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getWhen</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">()));</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(beep){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">            Toolkit.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getDefaultToolkit</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">beep</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">	}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> listener</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> TimePrinter</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>TalkingClock类<strong>不再需要存储实例变量beep</strong>(这句话很重要)。局部类只是引用start中的参数。</p><p>可能有的人会说，这跟普通的代码没什么区别，为什么还要再写一遍呢？</p><p>注意:<strong>这里实现的是定时语音，也就是说会隔一段时间触发一次，但是start方法执行完之后beep将会消失，这是问题的关键</strong>。</p><p>为了更容易理解，我们来看一下整个控制流程:</p><p>1.调用start;</p><p>2.调用内部类TimePrinter的构造器，初始化listener变量；</p><p>3.将listener引用传递给Timer构造器，定时器开始计时，start方法退出，beep不复存在。</p><p>4.1s后，actionPerformed方法执行if(beep)...</p><p>为了能够让actionPerformed方法工作，TimePrinter类在beep参数消失之前复制为start方法的局部变量(可以看看对象和类那儿方法参数的笔记)。</p><p>下面这段话可能很拗口</p>`,250),F={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},m={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.452ex"},xmlns:"http://www.w3.org/2000/svg",width:"75.097ex",height:"2.149ex",role:"img",focusable:"false",viewBox:"0 -750 33193 950","aria-hidden":"true"},u=t('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z" style="stroke-width:3;"></path></g><g data-mml-node="mi" transform="translate(429,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z" style="stroke-width:3;"></path></g><g data-mml-node="mi" transform="translate(895,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z" style="stroke-width:3;"></path></g><g data-mml-node="mi" transform="translate(1361,0)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z" style="stroke-width:3;"></path></g><g data-mml-node="mi" transform="translate(1864,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">实</text></g><g data-mml-node="mi" transform="translate(2864,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">例</text></g><g data-mml-node="mi" transform="translate(3864,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">变</text></g><g data-mml-node="mi" transform="translate(4864,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">量</text></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(5864,0)"><g data-mml-node="mo"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">。</text></g></g><g data-mml-node="mi" transform="translate(6864,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">当</text></g><g data-mml-node="mi" transform="translate(7864,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">创</text></g><g data-mml-node="mi" transform="translate(8864,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">建</text></g><g data-mml-node="mi" transform="translate(9864,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">一</text></g><g data-mml-node="mi" transform="translate(10864,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">个</text></g><g data-mml-node="mi" transform="translate(11864,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">对</text></g><g data-mml-node="mi" transform="translate(12864,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">象</text></g><g data-mml-node="mi" transform="translate(13864,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(14864,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">，</text></g><g data-mml-node="mi" transform="translate(15864,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z" style="stroke-width:3;"></path></g><g data-mml-node="mi" transform="translate(16293,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z" style="stroke-width:3;"></path></g><g data-mml-node="mi" transform="translate(16759,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z" style="stroke-width:3;"></path></g><g data-mml-node="mi" transform="translate(17225,0)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z" style="stroke-width:3;"></path></g><g data-mml-node="mi" transform="translate(17728,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">值</text></g><g data-mml-node="mi" transform="translate(18728,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">就</text></g><g data-mml-node="mi" transform="translate(19728,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">会</text></g><g data-mml-node="mi" transform="translate(20728,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">传</text></g><g data-mml-node="mi" transform="translate(21728,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">递</text></g><g data-mml-node="mi" transform="translate(22728,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">给</text></g><g data-mml-node="mi" transform="translate(23728,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">构</text></g><g data-mml-node="mi" transform="translate(24728,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">造</text></g><g data-mml-node="mi" transform="translate(25728,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">器</text></g><g data-mml-node="mi" transform="translate(26728,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">，</text></g><g data-mml-node="mi" transform="translate(27728,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">并</text></g><g data-mml-node="mi" transform="translate(28728,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">存</text></g><g data-mml-node="mi" transform="translate(29728,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">储</text></g><g data-mml-node="mi" transform="translate(30728,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">在</text></g><g data-mml-node="mi" transform="translate(31728,0)"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z" style="stroke-width:3;"></path></g><g data-mml-node="mi" transform="translate(32213,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z" style="stroke-width:3;"></path></g><g data-mml-node="mi" transform="translate(32742,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z" style="stroke-width:3;"></path></g></g></g>',1),E=[u],v=s("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("mi",null,"b"),s("mi",null,"e"),s("mi",null,"e"),s("mi",null,"p"),s("mi",{mathvariant:"normal"},"实"),s("mi",{mathvariant:"normal"},"例"),s("mi",{mathvariant:"normal"},"变"),s("mi",{mathvariant:"normal"},"量"),s("mrow",{"data-mjx-texclass":"ORD"},[s("mo",null,"。")]),s("mi",{mathvariant:"normal"},"当"),s("mi",{mathvariant:"normal"},"创"),s("mi",{mathvariant:"normal"},"建"),s("mi",{mathvariant:"normal"},"一"),s("mi",{mathvariant:"normal"},"个"),s("mi",{mathvariant:"normal"},"对"),s("mi",{mathvariant:"normal"},"象"),s("mi",{mathvariant:"normal"},"时"),s("mi",null,"，"),s("mi",null,"b"),s("mi",null,"e"),s("mi",null,"e"),s("mi",null,"p"),s("mi",{mathvariant:"normal"},"值"),s("mi",{mathvariant:"normal"},"就"),s("mi",{mathvariant:"normal"},"会"),s("mi",{mathvariant:"normal"},"传"),s("mi",{mathvariant:"normal"},"递"),s("mi",{mathvariant:"normal"},"给"),s("mi",{mathvariant:"normal"},"构"),s("mi",{mathvariant:"normal"},"造"),s("mi",{mathvariant:"normal"},"器"),s("mi",null,"，"),s("mi",{mathvariant:"normal"},"并"),s("mi",{mathvariant:"normal"},"存"),s("mi",{mathvariant:"normal"},"储"),s("mi",{mathvariant:"normal"},"在"),s("mi",null,"v"),s("mi",null,"a"),s("mi",null,"r")])],-1),b=s("strong",null,"编译器检测对局部变量的访问(就是说在编译时已经注意到了对于beep局部变量的访问)，为每一个变量建立相应的实例字段，并将局部变量复制到构造器(内部类的构造器)，从而能够初始化这些字段",-1),f=t(`<h3 id="匿名内部类" tabindex="-1">匿名内部类 <a class="header-anchor" href="#匿名内部类" aria-label="Permalink to &quot;匿名内部类&quot;">​</a></h3><p>使用局部内部类时如果还想更进一步，<strong>只想创建对象</strong>，那么就不需要指定类的名字。这样的一个类被称为<strong>匿名内部类</strong>。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> vodi </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">start</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> interval,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> beep){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> listener</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> ActionListener</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;At the tone the time is&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">+</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">Instant</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">ofEpochMilli</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(event.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getWhen</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">());</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">       	if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(beep){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">            Toolkit.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getDefaultToolkit</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">beep</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    };</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">    var</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;"> timer</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">new</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;"> Timer</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(interval,listener); </span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">    timer</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">start</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>含义是创建一个类的对象，这个类实现了ActionListener接口，并且需要实现的actionPerformed方法放在{}中实现。</p><p>一般语法</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> SuperType</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(construction parameters){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    inner </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> methods</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> and data</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p><strong>SuperType可以是接口，也可以是一个类，如果是类，内部类就要扩展这个类</strong>。</p><p>由于匿名内部类没有类名，而构造器必须与类名相同，所以匿名内部类没有构造器。实际上，<strong>构造参数要传递给超类(superclass)构造器</strong>。</p><p>具体地，只要内部类实现了一个接口，就不能有任何构造参数。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> InterfaceType</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">	...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>一个类的新对象和构造一个扩展了这个类的匿名内部类的区别</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Person</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;Jack&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Person</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;Marry&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){...};</span></span></code></pre></div><p>从上面的代码中很容易能够看出来，匿名内部类后面有{}</p><p>注:匿名内部类不能有构造器，但可以提供一个对象初始化块</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;Marry&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    {initialzation}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">};</span></span></code></pre></div><p>警告:建立一个与超类大体类似的匿名子类通常会很方便。不过，对于equals方法要特别当心。之前的equals方法使用了下面的测试</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getClass</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">!</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">other.class){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>对于匿名子类做这个测试会失败。</p><h3 id="静态内部类" tabindex="-1">静态内部类 <a class="header-anchor" href="#静态内部类" aria-label="Permalink to &quot;静态内部类&quot;">​</a></h3><p>如果使用内部类只是为了把一个类隐藏在另外一个类的内部，并不需要内部类有外部类对象的一个引用。为此，<strong>可以将内部类声明为static,这样就不会生成那个引用</strong>(外围类对象)。</p><p>下面来看一个典型的例子。考虑这样一个任务:计算数组中的最小值和最大值。当然，可以编写两个方法，一个方法用于计算最小值，一个方法用于计算最大值。在调用这个方法的时候，数组被遍历两遍。如果只需要遍历数组一次，并能够同时计算出数组的最大值和最小值，则可以提高效率。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">double</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> min</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Double.POSITIVE_INFINITY;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">double</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> max</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Double.NEGATIVE_iNFINITY;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">double</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> v</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">value){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(v</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">min)min</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">v;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(v</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">max)max</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">v;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>由于需要同时返回最大值和最小值，所以可以定义一个包含两个值的类Pair。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> Pair</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> double</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> first;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> double</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> second;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> Pair</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">double</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;"> f</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">double</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;"> s</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        first</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">f;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        second</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">s;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> double</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> getFirst</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> first;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> double</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> getSecond</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> second;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>minmax方法可以反回一个Pair类型的对象。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> ArrayAlg</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Pair </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">minmax</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">double</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">values</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> Pair</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(min,max);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>这个方法的调用这可以使用getFirst和getSecond方法获得答案</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Pair</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> p</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">ArrayAlg.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">minmax</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(d);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;min=&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">p.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getFirst</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">());</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;max=&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">p.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getSecond</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">());</span></span></code></pre></div><p>通常由于Pair这个类名的普遍性，所以容易造成类名的混淆(在一个大项目中，其他人也定义了这个类，可能里面定义了两个字符串字段)。为了解决这个冲突，将Pair定义为ArrayAlg的一个公共内部类(公共的意思就是用public来进行修饰)，就可以通过Arrayalg.Pair访问它了。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">ArrayAlg</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Pair</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> p</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">ArrayAlg.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">minmax</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(d);</span></span></code></pre></div><p>不过，与之前的例子所使用的内部类不同，在Pair对象中不需要任何其他对象的引用，为此，可以将这个内部类声明为static，从而不生成那个引用:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> ArrayAlg</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> Pair</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>在上面的实例中，必须使用静态内部类，因为内部类对象实在静态方法中构造的。</p><p>如果没有将Pair声明为static,那么编译器将会报错，指出没有可用的隐式ArrayAlg类型对象来初始化内部类对象。</p><h4 id="注意" tabindex="-1">注意 <a class="header-anchor" href="#注意" aria-label="Permalink to &quot;注意&quot;">​</a></h4><p>1.凡是不需要访问外围类对象的内部类就应该是静态内部类。</p><p>2.之前我们提到过内部类不允许有静态方法，静态内部类可以有静态字段和方法。</p><p>3.在接口中声明的内部类自动是public和static。</p><h2 id="服务加载器" tabindex="-1">服务加载器 <a class="header-anchor" href="#服务加载器" aria-label="Permalink to &quot;服务加载器&quot;">​</a></h2><p>通常提供一个服务时，程序希望服务设计者能有一些自由，能够确定如何实现服务的特性。另外还希望有多个实现以供选择。<strong>利用ServiceLoader类可以很容易地加载符合一个公共接口的服务</strong>。 假设有一个接口，其中包含服务的各个实例应当提供的方法。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">package</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> service</span><span style="--shiki-light:#B31D28;--shiki-dark:#FF938A;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">L</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">oader;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> Cipher</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">	byte</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">[] </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">encrypt</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">byte</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">source</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">byte</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    byte</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">[] </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">decrypt</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">byte</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">source</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">byte</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> strlength</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>服务提供者可以提供一个或者多个实现这个服务的类，例如，</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">package</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> service</span><span style="--shiki-light:#B31D28;--shiki-dark:#FF938A;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">L</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">oader.impl;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> calss CaesarCipher implements Cipher{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>实现类可以放在任意的包中，而不一定是服务接口所在的包。<strong>每个实现类必须有一个无参数构造器</strong>(类会调用超类的无参构造器，而接口必须有无参构造器)。 现在，将类名增加至META-INF/services目录下的一个UTF-8编码文本文件中，<strong>文件名必须与完全限定类名一致</strong>。 程序可以如下初始化一个服务加载器:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> ServiceLoader</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Cipher</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&gt; </span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">cipher</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">ServiceLoader.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">load</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Cipher.class);</span></span></code></pre></div><p>这个初始化只在程序中完成一次。 服务加载器的iterator方法会返回一个迭代器来处理所提供服务的所有实现(实现类)。最容易的是通过一个增强的for循环来进行遍历，在循环中选择一个适当的。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Cipher </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getCipher</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> minStrength){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Cipher</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> cipher</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">cipherLoader){ </span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">//implicitly calls cipherLoader.iterator()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(cipher.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">strength</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">minStrength){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">            return</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> cipher;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>也可以使用stream流(数据集合)来查找所要的服务。<strong>stream方法会生成ServiceLoader.Provider实例的一个流</strong>。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Optional</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Cipher</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> getCipher2</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> minStrength){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> cipherLoader.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">stream</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">filter</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(descr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">descr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">type</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">serviceLoader.impl.CaesarCipher.class)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">findFirst</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(ServiceLoader.Provider</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">::</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">get);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>最后，如果想要得到任何服务实例，只是需要调用findFirst。 Optional&lt;Cipher&gt; cipher=cipherLoader.findFirst();</p><h4 id="常用api-1" tabindex="-1">常用API <a class="header-anchor" href="#常用api-1" aria-label="Permalink to &quot;常用API&quot;">​</a></h4><h5 id="java-util-serviceloader-s" tabindex="-1">java.util.ServiceLoader&lt;S&gt; <a class="header-anchor" href="#java-util-serviceloader-s" aria-label="Permalink to &quot;java.util.ServiceLoader\\&lt;S&gt;&quot;">​</a></h5><p>static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) 创建一个服务加载器来加载实现给定服务接口的类。 Iterator&lt;S&gt; iterator() 生成一个以“懒”方式加载服务类的迭代器。也就是说，<strong>迭代器推进时才会加载类</strong>。 Stream&lt;ServiceLoader.Provider&lt;S&gt;&gt; stream() 返回提供者描述的一个流，从而可以采用懒方式加载所要的类的提供者。 Optional&lt;S&gt; findFirst() 查找第一个可用的服务提供者(如果有)。</p><h5 id="java-util-serviceloader-provider-s" tabindex="-1">java.util.ServiceLoader.Provider&lt;S&gt; <a class="header-anchor" href="#java-util-serviceloader-provider-s" aria-label="Permalink to &quot;java.util.ServiceLoader.Provider\\&lt;S&gt;&quot;">​</a></h5><p>Class&lt;? extends S&gt; type() 获得这个提供者的类型。 S get() 获得这个提供者的实例。</p><h2 id="jdk动态代理" tabindex="-1">JDK动态代理 <a class="header-anchor" href="#jdk动态代理" aria-label="Permalink to &quot;JDK动态代理&quot;">​</a></h2><h3 id="从静态代理开始" tabindex="-1">从静态代理开始 <a class="header-anchor" href="#从静态代理开始" aria-label="Permalink to &quot;从静态代理开始&quot;">​</a></h3><p>首先必须知道什么是静态代理,一般的场景是一个接口、一个接口的实现类,我们须手动编写这个实现类的代理类,示例代码如下</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> Product</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> addPrice</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(String </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">price</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> Stone</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> Product</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> addPrice</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(String </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">price</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">        //...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> Square</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> Product</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    Stone</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> stone</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> Stone</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> addPrice</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(String </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">price</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        stone.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">addPrice</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">        //...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>静态代理的弊端???</p><ol><li>如果新增一个方法,那么代理类中也需要增加方法</li><li>针对每个实现类都需要写一个代理类 利用动态代理(proxy)在运行时<strong>创建了一组给定接口的新类</strong>。只有在编译时无法确定需要实现哪个接口才需要使用代理。 相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都<strong>单独创建一个代理类</strong>，并且也<strong>不需要我们必须实现接口，我们可以直接代理实现类</strong>( CGLIB 动态代理机制)</li></ol><h3 id="何时使用代理" tabindex="-1">何时使用代理 <a class="header-anchor" href="#何时使用代理" aria-label="Permalink to &quot;何时使用代理&quot;">​</a></h3><p>假设我们需要创建一个类的对象，这个类可能实现了一个或者多个接口，但是在编译时不知道这些接口是什么。回想一下之前，如果是想要构造具体的类的话，那么我们可以里用newInstance或者反射来创建一个类的对象实例(通过找到构造器)。但是，<strong>不能实例化接口</strong>，需要在运行的程序中定义一个新类。 为了解决这个问题，有些程序会生成代码，将这些代码放在一个文件中，调用编译器，然后再加载得到类文件。但是，这样做的速度很慢，而且需要<strong>将编译器连同程序一起部署</strong>。 而代理机制是更好的解决方案，代理类可以在<strong>运行</strong>的时候由<strong>JVM</strong>创建全新的类。这样的代理类能够实现你指定的接口。具体的，代理类包含以下方法: 1.指定接口所需要的全部方法 2.Object类中的全部方法，例如，toString、equlas等。 说实话，上面的这些话我看了半天还是不太理解，从网上的关于代理模式的博文中我有了更加直观的了解。 <a href="https://xie.infoq.cn/article/9a9387805a496e1485dc8430f" target="_blank" rel="noreferrer">https://xie.infoq.cn/article/9a9387805a496e1485dc8430f</a><strong>代理类和委托类有相同的方法</strong>，代理类为委托类做了<strong>消息的预处理、过滤或者调用委托类的方法以及事后的处理</strong>。 <img src="https://gitee.com/aryangzhu/picture/raw/master/java/%E9%80%89%E5%8C%BA_025.png" alt=""> 有几点我们需要注意: 1.<strong>用户只在乎接口功能，而不关心是谁实现的</strong>。 2.接口的真正实现者是<strong>RealSubject，但是它不与用户直接接触</strong>，而是通过代理。 3.代理就是上图中的Proxy，由于它实现了Subject,所以它可以和用户直接接触。 4.用户调用Proxy时，Proxy内部调用了RealSubject的方法,是对RealSubject的方法的增强。</p><h3 id="invocationhandler接口" tabindex="-1">InvocationHandler接口 <a class="header-anchor" href="#invocationhandler接口" aria-label="Permalink to &quot;InvocationHandler接口&quot;">​</a></h3><p>不能在运行时为这些方法提供新代码，必须提供一个<strong>调用处理器</strong>(invocation handler)。调用处理器是实现了<strong>InvocationHandler</strong>接口的类的对象。这个接口只有一个方法:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Object </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">invoke</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Object proxy,Method method,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Object</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">[] args)</span></span></code></pre></div><p>分别有三个参数 代理类 proxy 调用方法 method 方法参数 args 无论何时调用代理对象的方法(proxy)，<strong>调用处理器的invoke方法都会被调用，并向其传递Method对象和原调用的参数</strong>。之后调用处理器必须确定如何处理这个调用。</p><h3 id="创建代理对象" tabindex="-1">创建代理对象 <a class="header-anchor" href="#创建代理对象" aria-label="Permalink to &quot;创建代理对象&quot;">​</a></h3><p>创建代理对象需要使用<strong>Proxy</strong>类的<strong>newProxyInstance</strong>(之前见过的类似的工厂方法)。<strong>这个方法有三个参数</strong>:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Object </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">newProxyInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(ClassLoader loader,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Class</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;?&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">[] interfaces,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> InvocationHandler h)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">throws IllegalArgumentException</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        ......</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span></code></pre></div><p>这是Proxy类中newProxyInstance方法的注释</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">//返回将方法调用分派到指定调用处理程序的指定接口的代理类的实例。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">//Proxy.newProxyInstance抛出IllegalArgumentException的原因与Proxy.getProxyClass相同。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">/**参数：</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">loader – 定义代理类的类加载器</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">interfaces – 代理类要实现的接口列表</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">h - 将方法调用分派到的调用处理程序</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">回报：</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">具有代理类的指定调用处理程序的代理实例，该代理类由指定的类加载器定义并实现指定的接口</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">**/</span></span></code></pre></div><p>这是方法中的部分源码，可以看出，代理类是由类加载器定义并实现</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">/*</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">* Look up or generate the designated proxy class.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">*/</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Class</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&gt; </span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">cl</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> getProxyClass0</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(loader, intfs);</span></span></code></pre></div><p>1.<strong>一个类加载器</strong>(class loader)。作为Java安全模型的一部分，可以对平台和应用类、从因特网上下载的类等使用的加载器。 2.一个<strong>Class对象数组，每个元素对应需要实现的各个接口</strong>。 3.一个<strong>调用处理器(invocation handler)</strong>。</p><h3 id="jdk动态代理的使用步骤" tabindex="-1">JDK动态代理的使用步骤 <a class="header-anchor" href="#jdk动态代理的使用步骤" aria-label="Permalink to &quot;JDK动态代理的使用步骤&quot;">​</a></h3><ol><li><strong>自定义接口和实现类,这一步在静态代理里面也得有</strong></li><li>定义InvocationHandler接口并重写invoke方法,<strong>自己实现InvocaitonHandler接口的类中需要有是实现类</strong></li><li>使用Proxy.newProxyInstance(...)方法调用</li></ol><h4 id="两个需要解决的问题" tabindex="-1">两个需要解决的问题: <a class="header-anchor" href="#两个需要解决的问题" aria-label="Permalink to &quot;两个需要解决的问题:&quot;">​</a></h4><h5 id="如何定义处理器" tabindex="-1">如何定义处理器？ <a class="header-anchor" href="#如何定义处理器" aria-label="Permalink to &quot;如何定义处理器？&quot;">​</a></h5><h5 id="对于得到的代理对象能够做些什么" tabindex="-1">对于得到的代理对象能够做些什么？ <a class="header-anchor" href="#对于得到的代理对象能够做些什么" aria-label="Permalink to &quot;对于得到的代理对象能够做些什么？&quot;">​</a></h5><p>这两个问题取决于我们想要通过代理机制解决什么问题，可能会有如下目的:</p><ol><li>将方法调用路由到远程服务器(说实话不明白什么意思)。</li><li>为了调试，跟踪方法调用 上面只是两种场景,还有一种场景,Spring整合Mybatis之后,只用编写xml文件,用屁股想也知道只有接口肯定是无法工作的,那么就一定是在运行过程中动态生成了Dao的实现类 下面的例子中，我们使用代理和调用处理器跟踪方法调用。<strong>我们定义了一个TraceHandler包装器类存储包装的对象</strong>(将委托类包装在里面，查看委托类方法的调用情况)。其中的invoke方法会打印所调用方法的名称和参数，随后使用包装的对象作为隐式参数调用这个方法。</li></ol><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> TraceHandler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> InvocationHandler</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    private</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Object</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> target;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> TraceHandler</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Object </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">obj</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        target</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">t;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> invoke</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Object </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">proxy</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,,Method </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">m</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Object</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">throws</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Throwable{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">        //print name and parameters</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        ...</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">        //invoke actual method</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> m.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">invoke</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(target,args[]);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>接下来我们需要构造可以跟踪方法调用的代理对象</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Object</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;...&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">TraceHandler</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> handler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> TraceHandler</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(value);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Class</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">[] </span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">interfaces</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=new</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> Class</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">[]{Comparable.class};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Object</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> proxy</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Proxy.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">newProxyInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(ClassLoader.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getSystemClassLoader</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(),</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">                              new</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> Class</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">[]{Comparable.class},handler);</span></span></code></pre></div><p>只要在Proxy上调用了某个接口的方法，就会打印这个方法的名字和参数，之后再用value调用这个方法。 书上还有一个例子，使用代理对象跟踪一个二分查找。数组中填充整数1-1000的代理，调用Arrays类的binarySearch方法在数组张查找一个随机整数。最后打印匹配元素。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">//填充1-1000的代理对象</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">elements.length; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">     Integer</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">     TraceHandler</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> handler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> TraceHandler</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(value);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">     Object</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> proxy</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Proxy.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">newProxyInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(ClassLoader.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getSystemClassLoader</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(),</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">new</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> Class</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">[]{Comparable.class},handler);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">     elements[i]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">proxy;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Integer</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> Random</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">nextInt</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(elements.length)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> result</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Arrays.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">binarySearch</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(elements,key);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(result</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">   	System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(elements[result]);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>Integer类实现了Comparable接口。代理对象属于运行时定义的一个类，<strong>它也实现了Comparable接口</strong>。不过，它的compareTo调用了代理对象处理器的invoke方法。</p><h3 id="代理类的特性" tabindex="-1">代理类的特性 <a class="header-anchor" href="#代理类的特性" aria-label="Permalink to &quot;代理类的特性&quot;">​</a></h3><p>1.代理类总是在程序的运行过程中动态创建的。<strong>一旦被创建之后，他们就变成了常规类，与虚拟机中的任何其他类没有区别</strong>。 2.所有代理类都扩展了Proxy类。<strong>一个代理类只有一个实例字段-即调用处理器，它在Proxy超类中定义</strong>。完成代理对象任务所需要的任何额外数据都必须存储在调用处理器中。例如，代理Comparable对象时，TraceHandler就包装了任务苏需要的实际对象(Object target)。 3.如果没有定义代理类的名字，Oracle虚拟机中的Proxy类将生成一个以字符串$Proxy开头的类名。 4.<strong>对于特定的类加载器和预设的一组接口来说，只能有一个代理类</strong>。也就是说，如果使用同一个类加载器和接口数组调用了两次newProxyInstance方法，将得到同一个类的两个对象。也可以利用Class ProxyClass=Proxy.getProxyClass(null,interfaces)来获取这个类。 5.<strong>代理类总是public和final</strong>。因为如果代理类实现的所有接口都是public,这个代理类就不属于任何特定的包；否则，所有非公共的接口都必须属于同一个包，而代理类也必须属于这个包。 6.可以通过调用Proxy类的isProxyClass方法检测一个特定的Class对象是否代表一个代理类。</p><h4 id="常用api-2" tabindex="-1">常用API <a class="header-anchor" href="#常用api-2" aria-label="Permalink to &quot;常用API&quot;">​</a></h4><h5 id="java-lang-refelt-invocationhandler" tabindex="-1">java.lang.refelt.InvocationHandler <a class="header-anchor" href="#java-lang-refelt-invocationhandler" aria-label="Permalink to &quot;java.lang.refelt.InvocationHandler&quot;">​</a></h5><p>Object invoke(Object proxy,Method method,Object[] args) 定以这个方法完成一个动作(增强过程)，你希望只要在代理对象上调用一个方法就完成这个动作。</p><h5 id="java-lang-refelt-proxy" tabindex="-1">java.lang.refelt.Proxy <a class="header-anchor" href="#java-lang-refelt-proxy" aria-label="Permalink to &quot;java.lang.refelt.Proxy&quot;">​</a></h5><p>static Class&lt;?&gt; getProxyClass(ClassLoader loader,Class <code>&lt;?&gt;interfaces) 返回实现指定接口的代理类 static Object newProxyInstance(ClassLoader loader,Class\\&lt;?&gt;</code> interfaces,InvocationHandler handler) 构造实现指定接口的代理类对象实例。所有方法都调用给定处理器的invoke方法。 static boolean isProxyClass(Class&lt;?&gt; cl) 如果cl是一个代理类则返回true。</p><h2 id="cglib动态代理机制" tabindex="-1">CGLIB动态代理机制 <a class="header-anchor" href="#cglib动态代理机制" aria-label="Permalink to &quot;CGLIB动态代理机制&quot;">​</a></h2><h3 id="介绍" tabindex="-1">介绍 <a class="header-anchor" href="#介绍" aria-label="Permalink to &quot;介绍&quot;">​</a></h3><p>JDK动态代理有一个最的问题就是<strong>只能代理实现了接口的方法</strong> cglib动态代理中重要的是 <strong>MethodInterceptor接口</strong>和<strong>Enhacer类</strong> 其中MethodInterceptor接口中的<strong>intercept</strong>方法又是重中之重。</p><div class="language-Java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> MethodInterceptor</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> Callback</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    // 拦截被代理类中的方法</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Object </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">intercept</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Object </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">obj</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, java.lang.reflect.Method </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">method</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Object</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, MethodProxy </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">proxy</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">throws</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Throwable;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>参数: obj:要被代理的对象 method:被代理方法 args:方法参数 proxy:代理类</p><h3 id="使用步骤" tabindex="-1">使用步骤 <a class="header-anchor" href="#使用步骤" aria-label="Permalink to &quot;使用步骤&quot;">​</a></h3><ol><li>导入依赖</li><li>定义一个类</li><li><strong>自定义MethodInterceptor</strong>并重写intercept方法,intercept方法用于拦截被代理方法，与JDK动态代中的invoke方法类似</li><li><strong>通过Enhancer类的create()创建代理类</strong></li></ol><h3 id="javaguide示例" tabindex="-1">JavaGuide示例 <a class="header-anchor" href="#javaguide示例" aria-label="Permalink to &quot;JavaGuide示例&quot;">​</a></h3><p>1.定义发送短信的类</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> MessageService</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  public</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Strng </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">send</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(String </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">message</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    //dosomething</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> message;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>2.定义MethodInterceptore</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> DebugMethodInterceptor</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> MethodInterceptor</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  public</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Object </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">interceptor</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Object </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">o</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,Method </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">m</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Object</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">[]  </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,MethodProxy </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">proxy</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    //前增强</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    Object</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> object</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">proxy.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">invokeSuper</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(o,args);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    //后增强</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> object;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>3.获取代理类</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> CglibProxyFactory</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Object </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getProxy</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Class&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt; </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">clazz</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">      Enhancer</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> enhancer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> Enhancer</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">      enhancer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">setClassLoader</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(clazz.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getClassLoader</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">());</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">      enhancer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">setSuperClass</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(clazz);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">      enhancer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">setInteceptor</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> DebugInterceptor</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">());</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">      return</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> enhancer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">create</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>4.使用</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">MessageService</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> service</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(MessageService)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> CglibProxyFactory</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getProxy</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(MessageService.class);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">service.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">send</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span></code></pre></div><h3 id="jdk动态代理和cglib动态代理的区别" tabindex="-1">JDK动态代理和CGLIB动态代理的区别 <a class="header-anchor" href="#jdk动态代理和cglib动态代理的区别" aria-label="Permalink to &quot;JDK动态代理和CGLIB动态代理的区别&quot;">​</a></h3><ol><li>JDK只能代理接口或者接口的实现类,cglib可以代理普通类</li></ol>`,113);function T(a,x,j,P,Q,q){const e=r,k=g("ClientOnly");return n(),p("div",null,[C,o(k,null,{default:A(()=>{var l,h;return[(((l=a.$frontmatter)==null?void 0:l.aside)??!0)&&(((h=a.$frontmatter)==null?void 0:h.showArticleMetadata)??!0)?(n(),y(e,{key:0,article:a.$frontmatter},null,8,["article"])):c("",!0)]}),_:1}),B,s("p",null,[i("请注意构造器的boolean参数和var"),s("mjx-container",F,[(n(),p("svg",m,E)),v]),i("beep字段中(也就是说对象中会有形如var$beep的字段)。"),b,i("(个人理解是编译器会生成一个构造器里面有这个参数，图上的结果中确实也有)。")]),f])}const I=d(D,[["render",T]]);export{M as __pageData,I as default};
