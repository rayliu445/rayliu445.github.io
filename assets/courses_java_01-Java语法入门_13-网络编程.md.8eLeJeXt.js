import{_ as a,o as t,c as e,R as o}from"./chunks/framework.FVQzxbLi.js";const P=JSON.parse('{"title":"13-基本程序设计结构","description":"","frontmatter":{"title":"13-基本程序设计结构","author":"Ray","date":"2020/10/02 21:30","categories":["Java生态"],"tags":["Java","Java基础","JDK","开发环境"]},"headers":[],"relativePath":"courses/java/01-Java语法入门/13-网络编程.md","filePath":"courses/java/01-Java语法入门/13-网络编程.md","lastUpdated":1742489594000}'),r={name:"courses/java/01-Java语法入门/13-网络编程.md"},i=o('<h2 id="网络编程基础" tabindex="-1">网络编程基础 <a class="header-anchor" href="#网络编程基础" aria-label="Permalink to &quot;网络编程基础&quot;">​</a></h2><h3 id="常见概念" tabindex="-1">常见概念 <a class="header-anchor" href="#常见概念" aria-label="Permalink to &quot;常见概念&quot;">​</a></h3><h4 id="osi7层与tcp-ip模型" tabindex="-1">OSI7层与TCP/IP模型 <a class="header-anchor" href="#osi7层与tcp-ip模型" aria-label="Permalink to &quot;OSI7层与TCP/IP模型&quot;">​</a></h4><h5 id="osi" tabindex="-1">OSI <a class="header-anchor" href="#osi" aria-label="Permalink to &quot;OSI&quot;">​</a></h5><h5 id="tcp-ip5层模型" tabindex="-1">TCP/IP5层模型 <a class="header-anchor" href="#tcp-ip5层模型" aria-label="Permalink to &quot;TCP/IP5层模型&quot;">​</a></h5><p>两种网络模型时对一个概念或者抽象事物的两种理解,当然5层模型更加容易理解</p><h2 id="tcp编程" tabindex="-1">TCP编程 <a class="header-anchor" href="#tcp编程" aria-label="Permalink to &quot;TCP编程&quot;">​</a></h2><p>首先需要了解Socket这个<strong>抽象概念</strong>,一个应用程序通过一个Socket来建立一个远程连接,而Socket内部通过TCP/IP协议把数据传输到网络。 Socket、TCP和部分IP的功能都是由操作系统提供的，不同的编程语言只是提供了对操作系统调用的简单封装。</p><h3 id="为什么需要socket" tabindex="-1">为什么需要Socket? <a class="header-anchor" href="#为什么需要socket" aria-label="Permalink to &quot;为什么需要Socket?&quot;">​</a></h3><p>因为同一台计算机某一时刻可能运行多个进程(多个应用程序),当应用程序接收到数据包的时候如果<strong>只有IP地址没法判断应该发送给哪个应用程序</strong>,所以操作系统抽象出Socket接口，每个应用程序对应到不同的Socket。</p><h4 id="socket的组成" tabindex="-1">Socket的组成 <a class="header-anchor" href="#socket的组成" aria-label="Permalink to &quot;Socket的组成&quot;">​</a></h4><p>IP地址+端口号(0-65535) Socket编程本质上就是<strong>两个进程之间的通信</strong>。其中一个进程必须充当服务器,它会主动监听某个指定端口。客户端必须主动连接服务器的ip地址和端口号。</p><h4 id="服务器端" tabindex="-1">服务器端 <a class="header-anchor" href="#服务器端" aria-label="Permalink to &quot;服务器端&quot;">​</a></h4><p>Java提供了<strong>ServerSocket</strong>来指定IP和端口的监听,同时需要一个<strong>Handler</strong>来处理Socket中的数据(一般流程就是拿到Socket里面的流对象进行处理)。</p><h4 id="客户端" tabindex="-1">客户端 <a class="header-anchor" href="#客户端" aria-label="Permalink to &quot;客户端&quot;">​</a></h4><p>使用Socket(InetAddress,port)连接服务器</p><h4 id="socket流" tabindex="-1">Socket流 <a class="header-anchor" href="#socket流" aria-label="Permalink to &quot;Socket流&quot;">​</a></h4><p>TCP协议基于流,和I/O流类似</p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><ol><li>服务器端用<strong>ServerSocket</strong>监听指定端口</li><li>客户端使用<strong>Socket</strong>(InetAddress,port)连接服务器</li><li>服务器端用**accept()**接收并返回Socket</li><li>双方通过Socket打开InputStream/OutputStream读写数据</li><li>服务器端通常使用多线程同时处理多个客户端连接,利用<strong>线程池</strong>可大幅提升效率</li><li>**flush()**用于强制刷新缓冲区到网络</li></ol><h2 id="http编程" tabindex="-1">HTTP编程 <a class="header-anchor" href="#http编程" aria-label="Permalink to &quot;HTTP编程&quot;">​</a></h2><h2 id="netty" tabindex="-1">Netty <a class="header-anchor" href="#netty" aria-label="Permalink to &quot;Netty&quot;">​</a></h2><h3 id="bio、nio和aio" tabindex="-1">BIO、NIO和AIO <a class="header-anchor" href="#bio、nio和aio" aria-label="Permalink to &quot;BIO、NIO和AIO&quot;">​</a></h3><p>JDK中提供一个更加方便快捷的包,参考资料 <a href="https://bugstack.cn/md/netty/base/2019-08-01-netty%E6%A1%88%E4%BE%8B%EF%BC%8Cnetty4.1%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87%E4%B8%80%E3%80%8A%E5%97%A8%EF%BC%81NettyServer%E3%80%8B.html" target="_blank" rel="noreferrer">https://bugstack.cn/md/netty/base/2019-08-01-netty案例，netty4.1基础入门篇一《嗨！NettyServer》.html</a></p><h3 id="服务端" tabindex="-1">服务端 <a class="header-anchor" href="#服务端" aria-label="Permalink to &quot;服务端&quot;">​</a></h3>',25),n=[i];function s(h,l,c,d,k,p){return t(),e("div",null,n)}const b=a(r,[["render",s]]);export{P as __pageData,b as default};
