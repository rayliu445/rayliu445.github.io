import{_ as h}from"./chunks/ArticleMetadata.Sb1DYAHo.js";import{_ as n,D as d,o,c as s,I as p,w as c,k as t,a as u,R as b,b as q,e as m}from"./chunks/framework.FVQzxbLi.js";import"./chunks/md5.RtphNWHi.js";const A=JSON.parse('{"title":"Web3入门","description":"","frontmatter":{"title":"Web3入门","author":"Ray","date":"2025/01/22 21:21","categories":["web3生态"],"tags":["web3","区块链"]},"headers":[],"relativePath":"courses/web3/index.md","filePath":"courses/web3/index.md","lastUpdated":1742732786000}'),f={name:"courses/web3/index.md"},P=t("h1",{id:"web3入门",tabindex:"-1"},[u("Web3入门 "),t("a",{class:"header-anchor",href:"#web3入门","aria-label":'Permalink to "Web3入门"'},"​")],-1),k=b('<p><strong>写在前面</strong></p><p>此笔记用做对web3的入门，同时对一些术语进行扫盲，内容里面不会包含区链块相关代码和合约代码，只是帮助大家有个概念，大部分内容来源于<a href="decert.me">decert.me</a>社区，大家也可以直接去看去看那边。</p><h2 id="简介" tabindex="-1">简介 <a class="header-anchor" href="#简介" aria-label="Permalink to &quot;简介&quot;">​</a></h2><h3 id="比特币的诞生" tabindex="-1">比特币的诞生 <a class="header-anchor" href="#比特币的诞生" aria-label="Permalink to &quot;比特币的诞生&quot;">​</a></h3><p>去中心化加密货币</p><p><a href="https://bitcoin.org/bitcoin.pdf" target="_blank" rel="noreferrer">《比特币：点对点的电子现金系统》</a>这篇论文代表着加密货币的诞生，我的理解其是公开透明、去中心化的交易网络。</p><h3 id="共识" tabindex="-1">共识 <a class="header-anchor" href="#共识" aria-label="Permalink to &quot;共识&quot;">​</a></h3><p>就是让所有参与网络上的节点(可以理解为一台计算机)都达成共一个看法，对于比特币来说就是所有节点看到和维护的都是同一个账本。</p><h4 id="pow工作量证明" tabindex="-1">POW工作量证明 <a class="header-anchor" href="#pow工作量证明" aria-label="Permalink to &quot;POW工作量证明&quot;">​</a></h4><p>POW(Proof of Worked)，率先完成工作量证明的节点，拥有区块的写入权，其他节点在此基础上进行后续的交易记录的工作量证明。</p><p>工作量证明的最重要的一个点是计算一个数学难题，类似于于哈希的破解，不断的去尝试，直到计算出结果，此时你就可以将交易信息打包并进行广播，链上完成验证后就会将区块链事实上写入区块链(&gt;51%)</p><h4 id="pos-权益证明" tabindex="-1">POS 权益证明 <a class="header-anchor" href="#pos-权益证明" aria-label="Permalink to &quot;POS 权益证明&quot;">​</a></h4><p>以太坊升级之后采用的共识机制，之前采用的是和比特币一样的POW。</p><p>POS(Proof of Stake)， 节点争夺记账权依靠的不是算力而是<strong>权益（占比）</strong>，权益通常是通过质押数字货币计算而来。<strong>PoS同样需要计算哈希值，当拥有的权益越多，满足Hash目标的机会越大，获得记账权的机会越大</strong>。同时质押的货币也作为抵押品防止作恶，如果节点有恶意行为，其抵押品可以被罚没（Slashing）。</p><p>节点在POS共识中，节点被称为验证者。</p><h4 id="poa权威证明" tabindex="-1">POA权威证明 <a class="header-anchor" href="#poa权威证明" aria-label="Permalink to &quot;POA权威证明&quot;">​</a></h4><p>选出中央权威来统一状态，违背了去中心化的思想。POS： Proof of Stake， 节点争夺记账权依靠的不是算力而是权益（占比），权益通常是通过质押数字货币计算而来。PoS同样需要计算哈希值，当拥有的权益越多，满足Hash目标的机会越大，获得记账权的机会越大。同时质押的货币也作为抵押品防止作恶，如果节点有恶意行为，其抵押品可以被罚没（Slashing）。</p><h3 id="加密货币的价值" tabindex="-1">加密货币的价值 <a class="header-anchor" href="#加密货币的价值" aria-label="Permalink to &quot;加密货币的价值&quot;">​</a></h3><p>具有&quot;货币&quot;的特性，比如:可流通性，可存储性，可分割性，同时对比法币有更好的稀缺性(比特币从一开始设置的个数就是有限个)</p><h2 id="如何交易" tabindex="-1">如何交易 <a class="header-anchor" href="#如何交易" aria-label="Permalink to &quot;如何交易&quot;">​</a></h2><p>这里有个概念叫做UTXO:Unspent Transaction Output，直译过来就是<strong>未花费输出</strong></p><p>这里廖雪峰老师的博客讲的更好</p><p>其实就是输入和输出，区块链上包含的就是这样的交易记录的集合</p><h3 id="如何验证交易" tabindex="-1">如何验证交易 <a class="header-anchor" href="#如何验证交易" aria-label="Permalink to &quot;如何验证交易&quot;">​</a></h3><p>对于交易f36abd，它记录的输入是3f96ab，索引是1(索引从0开始，0表示第一个输出，1表示第二个输出)，我们就根据3f96ab找到前面已经发生的交易，再根据索引号找到第一个输出，也就是1mPvuPA这条交易记录，对应的输入是0.5，0.5-(0.40+0.09)，扣的那0.1就是交易的手续费</p><h3 id="钱包" tabindex="-1">钱包 <a class="header-anchor" href="#钱包" aria-label="Permalink to &quot;钱包&quot;">​</a></h3><p>管理私钥(生成、存储、签名)的工具</p><h3 id="私钥-公钥-签名" tabindex="-1">私钥&amp;公钥&amp;签名 <a class="header-anchor" href="#私钥-公钥-签名" aria-label="Permalink to &quot;私钥&amp;公钥&amp;签名&quot;">​</a></h3><p>在比特币中，私钥本质上就是一个256位的随机整数，在进行加密时需要用到这串数字</p><p>公钥是根据私钥有ECDSA算法推算出来的，公钥有压缩和非压缩两种表示方法，可以互相转换</p><p>比特币地址是一串字符，相当于银行账号，公开发分享之后其他人可以向你发送比特币。</p><p>签名算法是使用私钥签名，公钥验证的方法，对一个消息的真伪进行确认。如果一个人持有私钥，他就可以使用<strong>私钥对任意的消息进行签名，即通过私钥 <code>sk</code>对消息 <code>message</code>进行签名</strong>，得到 <code>signature</code>。</p><p>签名的目的是为了证明，该消息确实是由持有私钥 <code>sk</code>的人发出的，任何其他人都可以对签名进行验证。验证方法是，由<strong>私钥持有人公开对应的公钥 <code>pk</code>，其他人用公钥 <code>pk</code>对消息 <code>message</code>和签名 <code>signature</code>进行验证</strong></p><h3 id="发起交易" tabindex="-1">发起交易 <a class="header-anchor" href="#发起交易" aria-label="Permalink to &quot;发起交易&quot;">​</a></h3><ol><li>交易输入：他们指向<strong>之前的交易创建的UTXO(可以是自己账户的UTXO，也可以是任何其他人发送给你并锁定到你地址上的UTXO)</strong>，通常钱包会收集当前可用的UTXO集合作为交易的输入</li><li>交易输出：表明多少比特币会锁定哪些地址，即生成新的UTXO</li><li>签名：用私钥来解锁交易输入的UTXO（就是用私钥对于输入的UTXO进行加密）</li></ol><h3 id="节点验证交易有效性" tabindex="-1">节点验证交易有效性 <a class="header-anchor" href="#节点验证交易有效性" aria-label="Permalink to &quot;节点验证交易有效性&quot;">​</a></h3><p>交易池mempool是未确认的交易的缓存，以便矿工从种挑出手续费率最高的交易，打包到区块中。</p><h3 id="使用工作量证明挖掘新区块" tabindex="-1">使用工作量证明挖掘新区块 <a class="header-anchor" href="#使用工作量证明挖掘新区块" aria-label="Permalink to &quot;使用工作量证明挖掘新区块&quot;">​</a></h3><p>创建一个新区块的过程差不多是这样的：</p><p>矿工从从交易池中找出最优的一组交易（在一个区块限制下，手续费收益最大），给这组交易创建merkle树， 然后不断的执行暴力哈希运算，以求解出满足一下 Hash 目标值的nonce值</p><h2 id="区块链技术" tabindex="-1">区块链技术 <a class="header-anchor" href="#区块链技术" aria-label="Permalink to &quot;区块链技术&quot;">​</a></h2><h3 id="概述" tabindex="-1">概述 <a class="header-anchor" href="#概述" aria-label="Permalink to &quot;概述&quot;">​</a></h3><p>狭义上说区块链是一种<strong>区块通过 Hash 方式(参考上面的图)形成的链式结构</strong>，因为链的环环相扣，任何一个区块上的修改，破坏链结构</p><h4 id="特点" tabindex="-1">特点 <a class="header-anchor" href="#特点" aria-label="Permalink to &quot;特点&quot;">​</a></h4><p>分布式账本技术、不可篡改的记录、智能合约</p><h3 id="智能合约-重点" tabindex="-1">智能合约(重点) <a class="header-anchor" href="#智能合约-重点" aria-label="Permalink to &quot;智能合约(重点)&quot;">​</a></h3><h4 id="以太坊" tabindex="-1">以太坊 <a class="header-anchor" href="#以太坊" aria-label="Permalink to &quot;以太坊&quot;">​</a></h4><p>一个区中心化的应用平台。</p><p>智能合约是区块链上可执行的代码，用户可以根据自己的业务需要上传自己的代码到以太坊上。</p><h4 id="区块链分叉" tabindex="-1">区块链分叉 <a class="header-anchor" href="#区块链分叉" aria-label="Permalink to &quot;区块链分叉&quot;">​</a></h4><p>因为区块链是分布式系统，每次升级，需要所有的节点客户端软件共同升级，有时一些节点因为利益或理念的不一致，拒绝升级到新的客户端，此时网络中将出现两个版本的客户端，运行新软件的节点就会用新的协议去构建新的区块，原有的客户端节点会继续用旧的协议来继续构建区块，各节点不认可对方的区块，此时就是会分叉出两条完全不同的链，这就是区块链的分叉，这种情况是硬分叉。</p><h5 id="硬分叉" tabindex="-1">硬分叉 <a class="header-anchor" href="#硬分叉" aria-label="Permalink to &quot;硬分叉&quot;">​</a></h5><p>硬分叉是共识的分裂或者改变</p><h5 id="软分叉" tabindex="-1">软分叉 <a class="header-anchor" href="#软分叉" aria-label="Permalink to &quot;软分叉&quot;">​</a></h5><p>软分叉向后兼容，没有更新的节点仍然会仍可新版本生成的区块，当升级后的区块链将无法识别尚未更新的节点的区块</p><h2 id="区块链分类" tabindex="-1">区块链分类 <a class="header-anchor" href="#区块链分类" aria-label="Permalink to &quot;区块链分类&quot;">​</a></h2><h3 id="公链" tabindex="-1">公链 <a class="header-anchor" href="#公链" aria-label="Permalink to &quot;公链&quot;">​</a></h3><p>公开的、透明，区块链上的信息对任何人都可见</p><h3 id="私链" tabindex="-1">私链 <a class="header-anchor" href="#私链" aria-label="Permalink to &quot;私链&quot;">​</a></h3><p>私链是一种不公开、只有被授权的节点才可以参与并查看数据的私有区块链，也称为许可链</p><h3 id="联盟链" tabindex="-1">联盟链 <a class="header-anchor" href="#联盟链" aria-label="Permalink to &quot;联盟链&quot;">​</a></h3><p>联盟链由多个组织共同拥有，由联盟内成员节点共同维护，节点通过授权后才能加入联盟网络。</p><h2 id="区块链分层" tabindex="-1">区块链分层 <a class="header-anchor" href="#区块链分层" aria-label="Permalink to &quot;区块链分层&quot;">​</a></h2><h3 id="layer0" tabindex="-1">Layer0 <a class="header-anchor" href="#layer0" aria-label="Permalink to &quot;Layer0&quot;">​</a></h3><p>还没有完全一致的理解，多数人认为是<strong>加密数据连接层及其硬件</strong></p><h3 id="layer1" tabindex="-1">Layer1 <a class="header-anchor" href="#layer1" aria-label="Permalink to &quot;Layer1&quot;">​</a></h3><p>比特币、以太坊、BSC和Solana等。这些区块链在自己的区块链上根据共识处理并完成最终的交易</p><p>第1层区块链为开发dApps提供了基础架构，开发者可以在第1层网络上开发其他协议，比如我们看到MAKER DAO稳定币协议、加密朋克以及Unisswap DEX协议等。</p><p>随着链上应用的增长，网络&quot;吞吐量&quot;无法快速地满足交易写入的需求，有两种解决的方向，一种扩大节点的存储容量，但是会提高节点参与网络的门槛，使得网络更加中心化；另一个是方法是以太坊在尝试的分片(sharding)扩容方案，将区块链数据分成不同的组(分片)，每个分片负责网络活动中的不同交易子集。</p><h3 id="layer2-二层网络" tabindex="-1">Layer2(二层网络) <a class="header-anchor" href="#layer2-二层网络" aria-label="Permalink to &quot;Layer2(二层网络)&quot;">​</a></h3><p>Layer2是针对底层区块链(Layer1)扩容的一种链下解决方案，Layer2是一个独立的区块链，但使用第一层的安全性保证。</p><p>扩容主要思想是将原本Layer1的交易放在链下(Layer2)执行，减轻Layer1的负担，并且Layer2定期于Layer1通信，将Layer2的交易批量提交到Layer1</p><h4 id="比特币闪电网络" tabindex="-1">比特币闪电网络 <a class="header-anchor" href="#比特币闪电网络" aria-label="Permalink to &quot;比特币闪电网络&quot;">​</a></h4><p>在比特币上的一个主要的Layer2扩容方案是闪电网络(Lighting Network)，为小额支付场景进行优化。闪电网络的主要实现是，支付的双方在链下建立一个通道，双方可以在这个通道多次交易，在需要结算时再写回链上。</p><h4 id="rollup-卷起" tabindex="-1">Rollup(卷起) <a class="header-anchor" href="#rollup-卷起" aria-label="Permalink to &quot;Rollup(卷起)&quot;">​</a></h4><p>Rollup的核心思想是把由Rollu层负责执行交易，然后许多笔交易压缩成一笔加以提交给以太坊。</p><h5 id="optimistic-rollup乐观" tabindex="-1">Optimistic Rollup乐观 <a class="header-anchor" href="#optimistic-rollup乐观" aria-label="Permalink to &quot;Optimistic Rollup乐观&quot;">​</a></h5><p>乐观假设从Layer2上执行的交易都是可信的，并批量提交到以太坊上，有个挑战期，期间内任何人都可以来验证交易的真实性，若挑战成功，原有交易被拒绝，并惩罚Layer2出块人。</p><h5 id="zk-rollup-零知识证明rollup" tabindex="-1">ZK Rollup 零知识证明Rollup <a class="header-anchor" href="#zk-rollup-零知识证明rollup" aria-label="Permalink to &quot;ZK Rollup 零知识证明Rollup&quot;">​</a></h5><p>而ZK Rollup则是通过生成一个零知识证明来证明所有交易的有效性，相比Optimistic Rollup没有乐观假设，而且具有更高的数据压缩率，就是开发难度很大。</p><h3 id="layer3" tabindex="-1">Layer3 <a class="header-anchor" href="#layer3" aria-label="Permalink to &quot;Layer3&quot;">​</a></h3><p>目前还没有一致认可的定义，L2用于扩容，L3用于自定义功能，例如隐私。</p><h2 id="web3与去中心化存储" tabindex="-1">web3与去中心化存储 <a class="header-anchor" href="#web3与去中心化存储" aria-label="Permalink to &quot;web3与去中心化存储&quot;">​</a></h2><h3 id="互联网演进" tabindex="-1">互联网演进 <a class="header-anchor" href="#互联网演进" aria-label="Permalink to &quot;互联网演进&quot;">​</a></h3><p>web1(只读)-&gt;web2(能读能写)-&gt;web3(能读能写能拥有)</p><h3 id="web3技术堆栈" tabindex="-1">web3技术堆栈 <a class="header-anchor" href="#web3技术堆栈" aria-label="Permalink to &quot;web3技术堆栈&quot;">​</a></h3><p>传统web2应用架构</p><p>Web3应用，技术架构则有所不同：</p><h3 id="去中心化存储" tabindex="-1">去中心化存储 <a class="header-anchor" href="#去中心化存储" aria-label="Permalink to &quot;去中心化存储&quot;">​</a></h3><p>区块链用于执行逻辑，是一个去中心化计算平台，并不是为存储大量数据而设计的，当我们需要保存图片、音频、视频等内容时，则需要适合大数据的存储方案。</p><h4 id="ipfs协议" tabindex="-1">IPFS协议 <a class="header-anchor" href="#ipfs协议" aria-label="Permalink to &quot;IPFS协议&quot;">​</a></h4><p>IPFS目标是取代HTTP去构建一个更好的去中心化的Web。 <strong>现有的HTTP网络服务，基于IP寻址的，就是IP找到内容所在的服务器，然后再与服务器交互</strong> 。而在IPFS的网络里是根据<strong>内容寻址</strong>的，我们上传到IPFS的文件都会产生哈希值，无需知道文件存储在哪里，通过哈希值就能够找到这个文件。</p><h4 id="arweave" tabindex="-1">Arweave <a class="header-anchor" href="#arweave" aria-label="Permalink to &quot;Arweave&quot;">​</a></h4><p>Arweave 是一个区块链网络，数据保存在网络中的区块里</p><h2 id="区块链应用场景" tabindex="-1">区块链应用场景 <a class="header-anchor" href="#区块链应用场景" aria-label="Permalink to &quot;区块链应用场景&quot;">​</a></h2><h3 id="金融服务" tabindex="-1">金融服务 <a class="header-anchor" href="#金融服务" aria-label="Permalink to &quot;金融服务&quot;">​</a></h3><h3 id="跨境支付-结算" tabindex="-1">跨境支付/结算 <a class="header-anchor" href="#跨境支付-结算" aria-label="Permalink to &quot;跨境支付/结算&quot;">​</a></h3><h3 id="资产数字化-代币化" tabindex="-1">资产数字化/代币化 <a class="header-anchor" href="#资产数字化-代币化" aria-label="Permalink to &quot;资产数字化/代币化&quot;">​</a></h3><h3 id="defi" tabindex="-1">DeFi <a class="header-anchor" href="#defi" aria-label="Permalink to &quot;DeFi&quot;">​</a></h3><p>DeFi，Decentralized Finance（去中心化金融）的缩写， 利用区块链智能合约在链上完成资产兑换、借贷、杠杆、期货等交易</p><h3 id="dao组织" tabindex="-1">DAO组织 <a class="header-anchor" href="#dao组织" aria-label="Permalink to &quot;DAO组织&quot;">​</a></h3><p>Decentralized Autonomous Organization，即去中心化自治组织，DAO是一种将组织的管理和运营规则以智能合约代码的形式编码在区块链上，DAO的决策基于组织成员持有的代码进行投票进行。</p><h3 id="数字存证-防伪" tabindex="-1">数字存证/防伪 <a class="header-anchor" href="#数字存证-防伪" aria-label="Permalink to &quot;数字存证/防伪&quot;">​</a></h3><p>区块链可以通过哈希时间戳证明某个文件或者数字内容在特定时间的存在，加之其公开、不可篡改、可溯源等特性。可以应用于产权、版权等所有权的管理和追踪，以及身份证明，司法鉴定。</p><h3 id="nft-数字艺术品" tabindex="-1">NFT/数字艺术品 <a class="header-anchor" href="#nft-数字艺术品" aria-label="Permalink to &quot;NFT/数字艺术品&quot;">​</a></h3><p>NFT（Non Fungible Token）非同质化代币，与 Token 一样也是智能合约的标准，NFT 用来表达具有独特特性的东西（两个东西不能互换）。</p><h3 id="游戏" tabindex="-1">游戏 <a class="header-anchor" href="#游戏" aria-label="Permalink to &quot;游戏&quot;">​</a></h3><p>基于 NFT 的以太猫（CryptoKitties）游戏在以太坊上线。用户可以通过以太币购买虚拟的以太猫，然后繁育下一代，同时也可以出售自己拥有的以太猫</p>',108);function x(a,g,_,y,w,O){const l=h,i=d("ClientOnly");return o(),s("div",null,[P,p(i,null,{default:c(()=>{var e,r;return[(((e=a.$frontmatter)==null?void 0:e.aside)??!0)&&(((r=a.$frontmatter)==null?void 0:r.showArticleMetadata)??!0)?(o(),q(l,{key:0,article:a.$frontmatter},null,8,["article"])):m("",!0)]}),_:1}),k])}const R=n(f,[["render",x]]);export{A as __pageData,R as default};
