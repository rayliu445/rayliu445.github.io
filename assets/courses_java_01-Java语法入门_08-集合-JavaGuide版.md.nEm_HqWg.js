import{_ as o}from"./chunks/ArticleMetadata.Sb1DYAHo.js";import{_ as g,D as c,o as t,c as A,I as n,w as l,k as d,a as y,R as k,b as p,e as r}from"./chunks/framework.FVQzxbLi.js";import"./chunks/md5.RtphNWHi.js";const P=JSON.parse('{"title":"08-集合-JavaGuide版","description":"","frontmatter":{"title":"08-集合-JavaGuide版","author":"Ray","date":"2020/10/02 21:30","categories":["Java生态"],"tags":["Java","Java基础","JDK","开发环境"]},"headers":[],"relativePath":"courses/java/01-Java语法入门/08-集合-JavaGuide版.md","filePath":"courses/java/01-Java语法入门/08-集合-JavaGuide版.md","lastUpdated":1742489594000}'),u={name:"courses/java/01-Java语法入门/08-集合-JavaGuide版.md"},C=d("h1",{id:"集合概述",tabindex:"-1"},[y("集合概述 "),d("a",{class:"header-anchor",href:"#集合概述","aria-label":'Permalink to "集合概述"'},"​")],-1),D=k('<h2 id="java集合概述" tabindex="-1">Java集合概述 <a class="header-anchor" href="#java集合概述" aria-label="Permalink to &quot;Java集合概述&quot;">​</a></h2><p>集合也被称作容器,主要由两大接口派生而来,一个是Collection接口,另一个是Map接口,主要用于存放键值对。</p><p><img src="https://gitee.com/aryangzhu/picture/raw/master/java/Java%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB.png" alt=""></p><h2 id="说说list、set、queue和map四者的区别" tabindex="-1">说说List、Set、Queue和Map四者的区别 <a class="header-anchor" href="#说说list、set、queue和map四者的区别" aria-label="Permalink to &quot;说说List、Set、Queue和Map四者的区别&quot;">​</a></h2><p>List:存储的元素是<strong>有序的、可重复的</strong>。</p><p>Set:存储的元素是无序的、不可重复的。</p><p>Queue:按特定的排队规则来确定先后顺序,存储的元素是有序的、可重复的。</p><p>Map:使用键值对(key-value)存储,类似于数学上的函数y=f(x)</p><h2 id="集合框架底层数据结构总结" tabindex="-1">集合框架底层数据结构总结 <a class="header-anchor" href="#集合框架底层数据结构总结" aria-label="Permalink to &quot;集合框架底层数据结构总结&quot;">​</a></h2><h3 id="collection接口下面的集合" tabindex="-1">Collection接口下面的集合 <a class="header-anchor" href="#collection接口下面的集合" aria-label="Permalink to &quot;Collection接口下面的集合&quot;">​</a></h3><h4 id="list" tabindex="-1">List <a class="header-anchor" href="#list" aria-label="Permalink to &quot;List&quot;">​</a></h4><h5 id="_1-arraylist-object-数组" tabindex="-1">1.ArrayList: Object[]数组 <a class="header-anchor" href="#_1-arraylist-object-数组" aria-label="Permalink to &quot;1.ArrayList: Object[]数组&quot;">​</a></h5><h5 id="_2-vector-object-数组" tabindex="-1">2.Vector:Object[] 数组 <a class="header-anchor" href="#_2-vector-object-数组" aria-label="Permalink to &quot;2.Vector:Object[] 数组&quot;">​</a></h5><h5 id="_3-linkedlist-双向链表-jdk1-7之后取消了循环链表" tabindex="-1">3.LinkedList:双向链表(jdk1.7之后取消了循环链表) <a class="header-anchor" href="#_3-linkedlist-双向链表-jdk1-7之后取消了循环链表" aria-label="Permalink to &quot;3.LinkedList:双向链表(jdk1.7之后取消了循环链表)&quot;">​</a></h5><h4 id="set" tabindex="-1">Set <a class="header-anchor" href="#set" aria-label="Permalink to &quot;Set&quot;">​</a></h4><h5 id="_1-hashset-无序-唯一-基于hashmap实现的-底层采用hashmap来保存元素" tabindex="-1">1.HashSet(无序,唯一):基于HashMap实现的,底层采用HashMap来保存元素 <a class="header-anchor" href="#_1-hashset-无序-唯一-基于hashmap实现的-底层采用hashmap来保存元素" aria-label="Permalink to &quot;1.HashSet(无序,唯一):基于HashMap实现的,底层采用HashMap来保存元素&quot;">​</a></h5><h5 id="_2-linkedhashset-linkedhashset是hashset的子类-并且内部是通过linkedhashmap来实现的-而linkedhashmap其内部是基于hashmap实现的一样。" tabindex="-1">2.LinkedHashSet:<strong>LinkedHashSet是HashSet的子类</strong>,并且内部是通过LinkedHashMap来实现的,而LinkedHashMap其内部是基于HashMap实现的一样。 <a class="header-anchor" href="#_2-linkedhashset-linkedhashset是hashset的子类-并且内部是通过linkedhashmap来实现的-而linkedhashmap其内部是基于hashmap实现的一样。" aria-label="Permalink to &quot;2.LinkedHashSet:**LinkedHashSet是HashSet的子类**,并且内部是通过LinkedHashMap来实现的,而LinkedHashMap其内部是基于HashMap实现的一样。&quot;">​</a></h5><h5 id="_3-treeset-有序-唯一-红黑树-自平衡的二叉排序树-。" tabindex="-1">3.TreeSet(有序,唯一):红黑树(自平衡的二叉排序树)。 <a class="header-anchor" href="#_3-treeset-有序-唯一-红黑树-自平衡的二叉排序树-。" aria-label="Permalink to &quot;3.TreeSet(有序,唯一):红黑树(自平衡的二叉排序树)。&quot;">​</a></h5><h4 id="queue" tabindex="-1">Queue <a class="header-anchor" href="#queue" aria-label="Permalink to &quot;Queue&quot;">​</a></h4><h5 id="_1-priorityqueue-obejct-数组来实现二叉堆" tabindex="-1">1.PriorityQueue:Obejct[] 数组来实现二叉堆 <a class="header-anchor" href="#_1-priorityqueue-obejct-数组来实现二叉堆" aria-label="Permalink to &quot;1.PriorityQueue:Obejct[] 数组来实现二叉堆&quot;">​</a></h5><h5 id="_2-arrayqueue-object-数组-双指针" tabindex="-1">2.ArrayQueue:Object[] 数组+双指针 <a class="header-anchor" href="#_2-arrayqueue-object-数组-双指针" aria-label="Permalink to &quot;2.ArrayQueue:Object[] 数组+双指针&quot;">​</a></h5><h2 id="map接口下的集合" tabindex="-1">Map接口下的集合 <a class="header-anchor" href="#map接口下的集合" aria-label="Permalink to &quot;Map接口下的集合&quot;">​</a></h2><h3 id="hashmap" tabindex="-1">HashMap <a class="header-anchor" href="#hashmap" aria-label="Permalink to &quot;HashMap&quot;">​</a></h3><p>jdk1.8之前HashMap由数组+ 链表组成的。数组是HashMap的主体,链表主要是为了解决哈希冲突而存在的(&quot;拉链法&quot;解决冲突)。<strong>JDK1.8之后在解决哈希冲突时有了较大的变化,当链表长度大于阈值(默认为8)(将链表转换成红黑树前会判断,如果当前数组的长度小于64,那么先会对数组进行扩容而不是转换成红黑树)时,将链表转换成红黑树,以减少搜索时间</strong>。</p><h3 id="linkedhashmap" tabindex="-1">LinkedHashMap <a class="header-anchor" href="#linkedhashmap" aria-label="Permalink to &quot;LinkedHashMap&quot;">​</a></h3><p>LinkedHashMap继承自HashMap,所以在<strong>它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成</strong>。另外,LinkedHashMap在上面结构的基础上,增加了一条由<strong>双向链表</strong>,使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作,实现了访问顺序的相关逻辑。</p><h2 id="如何选用集合" tabindex="-1">如何选用集合 <a class="header-anchor" href="#如何选用集合" aria-label="Permalink to &quot;如何选用集合&quot;">​</a></h2><p>根据<strong>集合特点</strong>来选用,比如需要根据键值获取到元素时就选用Map接口下的集合,需要排序时选择TreeMap,不需要排序时就选择HashMap,需要<strong>保证线程安全就选用ConcurrentHashMap</strong>。</p><p>当我们只需要存放元素值时,就选择实现Collection接口的集合,需要保证元素唯一时选择实现Set接口的集合比如TreeSet或HashSet,不需要就选择实现List接口的比如ArrayList或LinkedList,然后再根据这些接口的集合的特点来选用。</p><h2 id="为什么使用集合" tabindex="-1">为什么使用集合 <a class="header-anchor" href="#为什么使用集合" aria-label="Permalink to &quot;为什么使用集合&quot;">​</a></h2><p>1.为了应对数组长度不可变的场景;</p><p>2.同时,声明数组时的数据类型也决定了该数组存储的数据的类型;</p><p>3.数组存储的数据是有序的、可重复的,特点单一。但是集合提高了数据存储的灵活性,Java集合不仅可以用来存储不同类型不同数量的对象,还可以保存具有映射关系的数据。</p><h1 id="collection子接口之list" tabindex="-1">Collection子接口之List <a class="header-anchor" href="#collection子接口之list" aria-label="Permalink to &quot;Collection子接口之List&quot;">​</a></h1>',34),F=k('<h2 id="arraylist与vector的区别" tabindex="-1">ArrayList与Vector的区别？ <a class="header-anchor" href="#arraylist与vector的区别" aria-label="Permalink to &quot;ArrayList与Vector的区别？&quot;">​</a></h2><p>ArrayList是List的主要实现类,底层使用Object[]存储,适用于频繁的查找工作,线程不安全;</p><p>Vector是List的古老实现类,底层使用Object[]存储,线程安全的。</p><h2 id="arraylist与linkedlist区别" tabindex="-1">ArrayList与LinkedList区别？ <a class="header-anchor" href="#arraylist与linkedlist区别" aria-label="Permalink to &quot;ArrayList与LinkedList区别？&quot;">​</a></h2><p>1.是否保证<strong>线程安全</strong>:ArrayList和LinkedList都是不同步的,也就是不保证线程安全;</p><p>2.<strong>底层数据结构</strong>:ArrayList底层使用的是<strong>Object数组</strong>;LinkedList底层使用的是<strong>双向链表</strong>数据结构。</p><p>3.<strong>插入和删除是否受元素位置</strong>的影响:</p><p>a.ArrayList采用数组存储,所以插入和删除元素的时间复杂度受元素位置的影响。很容易理解,插入第i个位置时,时间复杂度就是O(n-i),因为在进行上述操作的时候集合中第i和第i个元素之后的(n-i)个元素都要执行向后位/向前位移一位的操作。</p><p>b.LinkedList采用的是链表存储,所以,如果是在头尾插入或者删除不受元素位置的影响(add(E e)、addFirst(E e)、addLast(E e)、removeFirst()、removeLast())近似O(1),如果是要在指定位置i插入和删除元素的话时间复杂度近似为O(n),因为需要先移动到指定位置再插入。</p><p>4.<strong>是否支持快速随机访问</strong>:LinkedList不支持高效的随机元素访问,而ArrayList支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。</p><p>5.<strong>内存占用</strong>:ArrayList的空间浪费主要体现在list列表的结尾会预留一定的容量空间,而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间(因为要存放直接后继和直接前驱以及数据)。</p><p>JavaGuide还提到了<strong>RandomAccess</strong>接口,在之前的IO中同样有RandomAccessFile接口。</p><p>ArrayList实现了RandomAccess接口而LinkedList没有实现。因为ArrayList底层是数组,而LinkedList底层是链表。数组天然支持随机访问,而链表不支持。</p><h1 id="collection的子接口之set" tabindex="-1">Collection的子接口之Set <a class="header-anchor" href="#collection的子接口之set" aria-label="Permalink to &quot;Collection的子接口之Set&quot;">​</a></h1>',14),b=k(`<h2 id="comparable和comparator的区别" tabindex="-1">Comparable和Comparator的区别 <a class="header-anchor" href="#comparable和comparator的区别" aria-label="Permalink to &quot;Comparable和Comparator的区别&quot;">​</a></h2><p>Comparable接口实际上出自java.lang包,它有一个compareTo(Object obj)方法用来排序。</p><p>Comparator接口实际上是出自java.util包它有一个compare(Object obj1,Object obj2)方法用来排序。</p><p>Guide哥的解释是自定义排序时就需要重写compareTo()方法或compare()方法,当我们需要对某一个集合实现两种排序方式,比如一个song对象中的歌名和歌手名分别采用一种排序方法的话,就可以重写compareTo()方法和使用自制的Comparator方法或者两个Comparator来实现歌名排序和歌手名排序。</p><p>下面的代码是定制的Comparator(比较器,作为参数传入)</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Collections.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">sort</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(arrayList,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">new</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Comparator&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Integer</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> compare</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Integer </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">o1</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,Integer </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">o2</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> o2.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">compareTo</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(o1);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">});</span></span></code></pre></div><p>重写compareTo方法实现年龄排序(实现方法,并且还是一个函数式接口)</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> Person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> Comparable</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Person</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">override</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> compareTo</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Person </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">o</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.age</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">o.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getAge</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">()){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">            return</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.age</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">o.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getAge</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">()){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">            return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><h2 id="无序性和不可重复性的含义是什么" tabindex="-1">无序性和不可重复性的含义是什么 <a class="header-anchor" href="#无序性和不可重复性的含义是什么" aria-label="Permalink to &quot;无序性和不可重复性的含义是什么&quot;">​</a></h2><p>1.什么是无序性?<strong>无序性不等于随机性,无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加,而是根据数据的哈希值决定的</strong>。</p><p>2.什么是不可重复性？不可重复性是指添加的元素按照equals()判断时,返回false,需要同时重写equals()方法和hashCode()方法。</p><h2 id="比较hashset、linkedhashset和treeset三者的异同" tabindex="-1">比较HashSet、LinkedHashSet和TreeSet三者的异同 <a class="header-anchor" href="#比较hashset、linkedhashset和treeset三者的异同" aria-label="Permalink to &quot;比较HashSet、LinkedHashSet和TreeSet三者的异同&quot;">​</a></h2><p>1.HashSet、LinkedLHashSet和TreeSeet都是Set接口的实现类,都能保证元素唯一,并且都不是线程安全的。</p><p>2.HashSet、LinkedHashSet和TreeSet的主要区别是在于底层数据结构不同。<strong>HashSet</strong>的底层数据结构是<strong>哈希表(基于HashMap实现)</strong>。<strong>LinkedHashSet</strong>的底层数据结构是<strong>链表和哈希表</strong>,元素的<strong>插入和取出顺序满足FIFO</strong>。TreeSet的底层数据结构是<strong>红黑树</strong>,元素是有序的,排序的方式有<strong>自然排序和定制排序</strong>。</p><p>3.底层数据结构不同导致这三者的应用场景不同。HashSet用于不需要保证元素插入和取出顺序的场景,LinkedHashSet用于保证元素的插入和取出顺序满足FIFO的场景,TreeSet用于支持元素自定义排序规则的场景。</p><h1 id="collection子接口之queue" tabindex="-1">Collection子接口之Queue <a class="header-anchor" href="#collection子接口之queue" aria-label="Permalink to &quot;Collection子接口之Queue&quot;">​</a></h1>`,16),m=k('<h2 id="queue与dequeue的区别" tabindex="-1">Queue与Dequeue的区别 <a class="header-anchor" href="#queue与dequeue的区别" aria-label="Permalink to &quot;Queue与Dequeue的区别&quot;">​</a></h2><p>queue是单端队列,只能从一端插入元素,另一端删除元素,实现上一般遵循<strong>先进先出</strong>(FIFO)规则。</p><p>Queue扩展了Collection接口,根据<strong>因为容量问题导致操作失败后处理方式的不同</strong>可以分为两类方法:一种在操作失败后会抛出异常,另一种则会返回特殊值。</p><table><thead><tr><th><code>Queue</code> 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队尾</td><td>add(E e)</td><td>offer(E e)</td></tr><tr><td>删除队首</td><td>remove()</td><td>poll()</td></tr><tr><td>查询队首元素</td><td>element()</td><td>peek()</td></tr></tbody></table><p>Deque是双端队列,在队列的<strong>两端均可插入或删除元素</strong>。</p><p>Dequeue扩展了Queue的接口,<strong>增加了在队首和队尾进行插入和删除的方法</strong>,同样根据失败后处理方式的不同分为两类:</p><table><thead><tr><th><code>Deque</code> 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队首</td><td>addFirst(E e)</td><td>offerFirst(E e)</td></tr><tr><td>插入队尾</td><td>addLast(E e)</td><td>offerLast(E e)</td></tr><tr><td>删除队首</td><td>removeFirst()</td><td>pollFirst()</td></tr><tr><td>删除队尾</td><td>removeLast()</td><td>pollLast()</td></tr><tr><td>查询队首元素</td><td>getFirst()</td><td>peekFirst()</td></tr><tr><td>查询队尾元素</td><td>getLast()</td><td>peekLast()</td></tr></tbody></table><p>Deque还提供有push()和pop()等其他方法,可用于模拟栈。</p><h2 id="arraydeque与linkedlist的区别" tabindex="-1">ArrayDeque与LinkedList的区别 <a class="header-anchor" href="#arraydeque与linkedlist的区别" aria-label="Permalink to &quot;ArrayDeque与LinkedList的区别&quot;">​</a></h2><p>ArrayDeque和LinkedList都实现了<strong>Deque接口</strong>,两者都具有队列的功能,两者有什么区别呢?</p><p>ArrayDeque是基于<strong>可变长的数组和双指针</strong>来实现,而LinkedList则通过<strong>链表</strong>来实现。</p><p>ArrayDeque<strong>不支持存储NULL数据</strong>,但LinkedList支持。 ArrayDeque是在JDK1.6才被引入的,而LinkedList早在JDK1.2时就已经存在。</p><p>ArrayDeque插入时可能存在扩容过程,不过均摊后的插入操作依然为O(1)。LinkedList每次插入数据都需要申请新的空间,均摊性能相比更慢。</p><h2 id="priorityqueue" tabindex="-1">PriorityQueue <a class="header-anchor" href="#priorityqueue" aria-label="Permalink to &quot;PriorityQueue&quot;">​</a></h2><p>在JDk1.5中被引入,与Queue的区别在于元素出队顺序是与优先级相关的,即总是优先级最高的元素出队。</p><p>1.PriorityQueue利用了<strong>二叉堆的数据结构来实现的,底层使用可变长的数组来存储数据</strong>。</p><p>2.PriorityQueue通过堆元素的上浮和下沉,<strong>实现了在O(logn)的时间复杂度插入元素和删除堆顶元素</strong>。</p><p>3.PriorityQueue默认是小顶堆,但<strong>可以接受一个Comparator作为构造参数,从而来自定义元素优先级的先后</strong>。</p><h1 id="map接口" tabindex="-1">Map接口 <a class="header-anchor" href="#map接口" aria-label="Permalink to &quot;Map接口&quot;">​</a></h1>',19),B=k(`<h2 id="hashmap和hashtable的区别" tabindex="-1">HashMap和HashTable的区别 <a class="header-anchor" href="#hashmap和hashtable的区别" aria-label="Permalink to &quot;HashMap和HashTable的区别&quot;">​</a></h2><h3 id="_1-线程是否安全" tabindex="-1">1.线程是否安全 <a class="header-anchor" href="#_1-线程是否安全" aria-label="Permalink to &quot;1.线程是否安全&quot;">​</a></h3><p>HashMap是非线程安全的,HashTable是线程安全的,因为HashTable内部的方法基本都经过synchronized修饰。</p><h3 id="_2-效率" tabindex="-1">2.效率 <a class="header-anchor" href="#_2-效率" aria-label="Permalink to &quot;2.效率&quot;">​</a></h3><p>HashMap更加高效一点(因为不用考虑线程安全),而且HashTable基本被淘汰。</p><h3 id="_3-对null-key和null-value的支持" tabindex="-1">3.对NULL key和NULL Value的支持 <a class="header-anchor" href="#_3-对null-key和null-value的支持" aria-label="Permalink to &quot;3.对NULL key和NULL Value的支持&quot;">​</a></h3><p>HashMap可以存储null的key和value,但null作为键只能有一个,null作为值可以有多个;HashTable不允许有null键和null值,否则会抛出NullPointerException。</p><h3 id="_4-初始容量大小和每次扩容量大小的不同" tabindex="-1">4.初始容量大小和每次扩容量大小的不同 <a class="header-anchor" href="#_4-初始容量大小和每次扩容量大小的不同" aria-label="Permalink to &quot;4.初始容量大小和每次扩容量大小的不同&quot;">​</a></h3><p>1.创建时如果不指定容量初始值,HashTable默认的<strong>初始值为11,之后每次扩容,容量变为原来的2n+1</strong>。HashMap默认的<strong>初始化大小为16</strong>,之后每次扩容,容量变为原来的2倍。</p><p>2.创建时如果给定了容量初始值,HashTable会直接使用你给定的大小,而HashMap会将其扩充为2的幂次方大小(HashMap中的tableSizeFor()方法保证),也就是<strong>说HashMap总是使用2的幂作为哈希表的大小</strong>。</p><h3 id="_5-底层数据结构" tabindex="-1">5.底层数据结构 <a class="header-anchor" href="#_5-底层数据结构" aria-label="Permalink to &quot;5.底层数据结构&quot;">​</a></h3><p>JDK1.8以后的HashMap在解决哈希冲突时有了较大的变化,当链表长度大于阈值(<strong>默认为8</strong>)(<strong>将链表转换为红黑树前会判断,如果当数组的长度小于64,那么会选择先进性数组扩容,而不是转换为红黑树</strong>)时,将链表转换为红黑树,以减少搜索时间。HashTable没有这样的机制。</p><p>HashMap中带有初始容量的构造函数:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> HashMap</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> initialCapacity, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">float</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> loadFactor) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (initialCapacity </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">            throw</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> IllegalArgumentException</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;Illegal initial capacity: &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> +</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">                                               initialCapacity);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (initialCapacity </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> MAXIMUM_CAPACITY)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">            initialCapacity </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> MAXIMUM_CAPACITY;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (loadFactor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> ||</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Float.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">isNaN</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(loadFactor))</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">            throw</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> IllegalArgumentException</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;Illegal load factor: &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> +</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">                                               loadFactor);</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.loadFactor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> loadFactor;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.threshold </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> tableSizeFor</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(initialCapacity);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">     public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> HashMap</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> initialCapacity) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(initialCapacity, DEFAULT_LOAD_FACTOR);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span></code></pre></div><p>下面这个方法保证了HashMap总是使用2的幂作为哈希表的大小</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> final</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> tableSizeFor</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> cap) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        int</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> cap </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">|=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;&gt;&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">|=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;&gt;&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">|=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;&gt;&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 4</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">|=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;&gt;&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 8</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">|=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;&gt;&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 16</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">?</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> :</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> MAXIMUM_CAPACITY) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> MAXIMUM_CAPACITY </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span></code></pre></div><h2 id="hashmap和hashset" tabindex="-1">HashMap和HashSet <a class="header-anchor" href="#hashmap和hashset" aria-label="Permalink to &quot;HashMap和HashSet&quot;">​</a></h2><p>前面学习Set的子接口的时候,我们已经知道HashSet的底层就是基于HashMap实现的。HashSet的源码非常非常少,因为除了**clone()、writeObject()、readObject()**是HashSet自己需要实现的以外,其他的方法都是直接调用HashMap中的方法。</p><table><thead><tr><th style="text-align:center;"><code>HashMap</code></th><th style="text-align:center;"><code>HashSet</code></th></tr></thead><tbody><tr><td style="text-align:center;">实现了 <code>Map</code> 接口</td><td style="text-align:center;">实现 <code>Set</code> 接口</td></tr><tr><td style="text-align:center;">存储键值对</td><td style="text-align:center;">仅存储对象</td></tr><tr><td style="text-align:center;">调用 <code>put()</code>向 map 中添加元素</td><td style="text-align:center;">调用 <code>add()</code>方法向 <code>Set</code> 中添加元素</td></tr><tr><td style="text-align:center;"><code>HashMap</code> 使用键（Key）计算 <code>hashcode</code></td><td style="text-align:center;"><code>HashSet</code> 使用成员对象来计算 <code>hashcode</code> 值，对于两个对象来说 <code>hashcode</code> 可能相同，所以 <code>equals()</code>方法用来判断对象的相等性</td></tr></tbody></table><h2 id="hashmap和treemap的区别" tabindex="-1">HashMap和TreeMap的区别 <a class="header-anchor" href="#hashmap和treemap的区别" aria-label="Permalink to &quot;HashMap和TreeMap的区别&quot;">​</a></h2><p>TreeMap和HashMap都继承自<strong>AbstractMap</strong>,但是需要注意的是TreeMap它还实现了Navigable接口和Sorted接口。</p><p>实现Navigable接口让TreeMap有了对集合内元素的搜索的能力。</p><p>实现SortedMap接口让TreeMap有了对集合中的元素根据键排序的能力。默认是按key的升序排序,不过也可以指定排序的比较器。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">[] args){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    TreeMap</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Person</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&gt; </span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">treeMap</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=new</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> TreeMap&lt;&gt;(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">new</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Comparator&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Person</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">override</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> compare</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Person </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">person1</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,Person </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">person2</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">            int</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> result</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">person1.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getAge</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">person2.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getAge</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">            return</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Integer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">compare</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(num,</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>总结:相比HashMap来说TreeMap主要多了对集合中的元素<strong>根据键值排序的能力以及对集合内元素的搜索能力</strong>。</p><h2 id="hashset如何检查重复" tabindex="-1">HashSet如何检查重复 <a class="header-anchor" href="#hashset如何检查重复" aria-label="Permalink to &quot;HashSet如何检查重复&quot;">​</a></h2><p>当你把对象加入 <code>HashSet</code>时，<code>HashSet</code> 会先计算对象的 <code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用 <code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p><p>在openJDK8中,实际上无论HashSet中是否已经存在了某元素,HashSet都会直接插入,只是会在add()方法的返回值处告诉我们插入前是否存在相同元素。</p><h3 id="hashcode-与equals" tabindex="-1">hashCode()与equals() <a class="header-anchor" href="#hashcode-与equals" aria-label="Permalink to &quot;hashCode()与equals()&quot;">​</a></h3><p>1.如果两个对象相等,hashcode一定相等。</p><p>2.两个对象相等,equals方法返回true</p><p>3.如果两个对象hashcode相等,他们也不一定相等</p><p>4.equals方法被覆盖过,则hashcode方法也必须被覆盖</p><p>5.hashcode()在堆上的对象产生独特值。<strong>如果没有重写hashCode(),则该class的两个对象无论如何也不会相等</strong>。</p><h3 id="与equals的区别" tabindex="-1">==与equals的区别 <a class="header-anchor" href="#与equals的区别" aria-label="Permalink to &quot;==与equals的区别&quot;">​</a></h3><p>对于==来说,比较的是值是否相等</p><p>对于引用类型来说,==比较的是两个引用是否指向同一个对象地址(两者在内存中存放的地址(堆内地址)是否指向同一个地方)。</p><p>对于引用类型(包括包装类型)来说,equals如果没有被重写,对比的就是地址;而如果被重写那么对比的就是内容。</p><h2 id="hashmap的底层实现" tabindex="-1">HashMap的底层实现 <a class="header-anchor" href="#hashmap的底层实现" aria-label="Permalink to &quot;HashMap的底层实现&quot;">​</a></h2><p>jdk1.8之前是数组+链表,即<strong>链表散列</strong>。HashMap通过key的hashCode经过扰动函数处理得到hash值,<strong>然后通过(n-1)&amp;hash判断当前元素存放的位置(这里的n指的是数组的长度)</strong>,如果当前位置存在元素的话,就判断该元素与要存入的元素的hash值以及key是否相同,如果相同的话，直接覆盖,不相同就通过拉链法解决冲突。</p><p>扰动函数就是HashMap的hash方法。使用hash方法也就是扰动函数是为了防止一些实现比较差的hashCode()方法,也就是为了减少碰撞。</p><p>JDk1.8中的源码</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> final</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> hash</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Object key){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> h;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">?</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(h</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">key.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">hashCode</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">())</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">^</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(h</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;&gt;&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">16</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>JDK1.7中源码</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> h </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">^=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (h </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;&gt;&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 20</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">^</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (h </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;&gt;&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 12</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> return</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> h </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">^</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (h </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;&gt;&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 7</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">^</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (h </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;&gt;&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 4</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span></code></pre></div><p>拉链法很容易理解:数据结构中也学过,这里不做过多阐述。</p><h2 id="hashmap的长度为什么是2的幂次方" tabindex="-1">HashMap的长度为什么是2的幂次方 <a class="header-anchor" href="#hashmap的长度为什么是2的幂次方" aria-label="Permalink to &quot;HashMap的长度为什么是2的幂次方&quot;">​</a></h2><p>为了让HashMap存取高效,需要尽可能地减少碰撞。Hash值的范围为-2147483648到2147483637,前后加起来大概40亿的映射空间,只要哈希函数映射得比较均匀松散,一般很难出现碰撞。但是40亿个地址计算机内存肯定放不下,所以使用模数取余的方法来对应数组存放位置下标(数组+链表),这个数组下标的计算方式是</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">hash</span></span></code></pre></div><p>也解释了HashMap的长度为什么是2的幂次方。</p><p><strong>取余(%)如果除数是2的幂次方则等价于与其除数减一的与(&amp;)操作</strong>,上面的代码等价于</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">hash</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">%</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">length</span></span></code></pre></div><p>前提是length是2的次方,并且&amp;要%性能更好。</p><h2 id="hashmap多线程导致死循环问题" tabindex="-1">HashMap多线程导致死循环问题 <a class="header-anchor" href="#hashmap多线程导致死循环问题" aria-label="Permalink to &quot;HashMap多线程导致死循环问题&quot;">​</a></h2><p>推荐使用ConcurrentHashMap。</p><h2 id="hashmap常见的遍历方式" tabindex="-1">HashMap常见的遍历方式 <a class="header-anchor" href="#hashmap常见的遍历方式" aria-label="Permalink to &quot;HashMap常见的遍历方式&quot;">​</a></h2><h2 id="concurrenthashmap线程安全的具体实现方式-底层具体实现" tabindex="-1">ConcurrentHashMap线程安全的具体实现方式/底层具体实现 <a class="header-anchor" href="#concurrenthashmap线程安全的具体实现方式-底层具体实现" aria-label="Permalink to &quot;ConcurrentHashMap线程安全的具体实现方式/底层具体实现&quot;">​</a></h2><p>主要体现在线程安全的方式上不同。</p><h3 id="_1-底层数据结构" tabindex="-1">1.底层数据结构 <a class="header-anchor" href="#_1-底层数据结构" aria-label="Permalink to &quot;1.底层数据结构&quot;">​</a></h3><p>JDK1.7的ConcurrentHashMap底层采用的是<strong>分段的数组+链表</strong>实现,JDK1.8采用的数据结构跟HashMap1.8的结构一样,数组+链表/红黑二叉树。HashTable和JDK1.8之前的HashMap的底层数据结构类似都是采用数组+链表形式,数组是HashMap的主体,链表则是为了解决哈希冲突而存在的。</p><h3 id="_2-实现线程安全的主要方式-重要" tabindex="-1">2.实现线程安全的主要方式(重要) <a class="header-anchor" href="#_2-实现线程安全的主要方式-重要" aria-label="Permalink to &quot;2.实现线程安全的主要方式(重要)&quot;">​</a></h3><p>1.在JDK1.7的时候,ConcurrentHashMap(分段锁)对整个桶数组进行了<strong>分割分段</strong>(segment),每一把锁只锁容器中一部分数据,多线程访问容器里不同数据端的数据,就不会存在锁竞争,提高了并发访问率。到了JDK1.8之后已经摒弃了Segment,转而采用的是数组+链表+红黑树的数据结构来实现,并发控制使用synchronized和CAS来操作。</p><p>JDK1.6之后对synchronized做了许多优化,所以ConcurrentHashMap就是线程安全的HashMap。</p><p>但是,JDK1.8之后的版本也有Segment的数据结构，为的是兼容以前的版本。</p><p>HashTable(同一把锁?):使用synchronized来保证线程安全,效率分厂低下。当一个线程访问同步方法时,其他线程也访问同步方法,可能会进入阻塞或者轮训状态,例如使用put方法,当一个线程持有锁时,另一个线程就不能put元素,竞争会越来越激烈。</p>`,65);function E(s,q,_,H,v,M){const e=o,h=c("ClientOnly");return t(),A("div",null,[C,n(h,null,{default:l(()=>{var a,i;return[(((a=s.$frontmatter)==null?void 0:a.aside)??!0)&&(((i=s.$frontmatter)==null?void 0:i.showArticleMetadata)??!0)?(t(),p(e,{key:0,article:s.$frontmatter},null,8,["article"])):r("",!0)]}),_:1}),D,n(h,null,{default:l(()=>{var a,i;return[(((a=s.$frontmatter)==null?void 0:a.aside)??!0)&&(((i=s.$frontmatter)==null?void 0:i.showArticleMetadata)??!0)?(t(),p(e,{key:0,article:s.$frontmatter},null,8,["article"])):r("",!0)]}),_:1}),F,n(h,null,{default:l(()=>{var a,i;return[(((a=s.$frontmatter)==null?void 0:a.aside)??!0)&&(((i=s.$frontmatter)==null?void 0:i.showArticleMetadata)??!0)?(t(),p(e,{key:0,article:s.$frontmatter},null,8,["article"])):r("",!0)]}),_:1}),b,n(h,null,{default:l(()=>{var a,i;return[(((a=s.$frontmatter)==null?void 0:a.aside)??!0)&&(((i=s.$frontmatter)==null?void 0:i.showArticleMetadata)??!0)?(t(),p(e,{key:0,article:s.$frontmatter},null,8,["article"])):r("",!0)]}),_:1}),m,n(h,null,{default:l(()=>{var a,i;return[(((a=s.$frontmatter)==null?void 0:a.aside)??!0)&&(((i=s.$frontmatter)==null?void 0:i.showArticleMetadata)??!0)?(t(),p(e,{key:0,article:s.$frontmatter},null,8,["article"])):r("",!0)]}),_:1}),B])}const T=g(u,[["render",E]]);export{P as __pageData,T as default};
