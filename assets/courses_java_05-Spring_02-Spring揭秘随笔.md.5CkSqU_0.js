import{_ as h}from"./chunks/ArticleMetadata.TT7jIO3o.js";import{_ as p,D as r,o as t,c as k,I as o,w as d,k as e,a as c,R as g,b as y,e as A}from"./chunks/framework.FHZ5yb6k.js";import"./chunks/md5.0oexlRJv.js";const P=JSON.parse('{"title":"Spring揭秘随笔","description":"","frontmatter":{"title":"Spring揭秘随笔","author":"Ray","date":"2022/12/25 14:49","categories":["Spring"],"tags":["Spring"]},"headers":[],"relativePath":"courses/java/05-Spring/02-Spring揭秘随笔.md","filePath":"courses/java/05-Spring/02-Spring揭秘随笔.md","lastUpdated":1743947440000}'),u={name:"courses/java/05-Spring/02-Spring揭秘随笔.md"},C=e("h1",{id:"spring揭秘随笔",tabindex:"-1"},[c("Spring揭秘随笔 "),e("a",{class:"header-anchor",href:"#spring揭秘随笔","aria-label":'Permalink to "Spring揭秘随笔"'},"​")],-1),D=g(`<h2 id="spring发展" tabindex="-1">Spring发展 <a class="header-anchor" href="#spring发展" aria-label="Permalink to &quot;Spring发展&quot;">​</a></h2><h3 id="时代发展" tabindex="-1">时代发展 <a class="header-anchor" href="#时代发展" aria-label="Permalink to &quot;时代发展&quot;">​</a></h3><h2 id="ioc部分" tabindex="-1">IOC部分 <a class="header-anchor" href="#ioc部分" aria-label="Permalink to &quot;IOC部分&quot;">​</a></h2><h3 id="ioc初入门" tabindex="-1">IOC初入门 <a class="header-anchor" href="#ioc初入门" aria-label="Permalink to &quot;IOC初入门&quot;">​</a></h3><h4 id="什么是ioc" tabindex="-1">什么是IOC <a class="header-anchor" href="#什么是ioc" aria-label="Permalink to &quot;什么是IOC&quot;">​</a></h4><p>IOC-Inversion Of Control,又名Denpendency Inject 从自己拿衣服到别人给你衣服 但是,你得通过某种方式来通知别人给你衣服 将代码调用者想象成个体的话,为你服务的角色就是IOC容器</p><h5 id="什么方式通知-依赖注入方式" tabindex="-1">什么方式通知(依赖注入方式) <a class="header-anchor" href="#什么方式通知-依赖注入方式" aria-label="Permalink to &quot;什么方式通知(依赖注入方式)&quot;">​</a></h5><h6 id="构造方法注入" tabindex="-1">构造方法注入 <a class="header-anchor" href="#构造方法注入" aria-label="Permalink to &quot;构造方法注入&quot;">​</a></h6><h6 id="setter方法注入" tabindex="-1">setter方法注入 <a class="header-anchor" href="#setter方法注入" aria-label="Permalink to &quot;setter方法注入&quot;">​</a></h6><h6 id="接口注入" tabindex="-1">接口注入 <a class="header-anchor" href="#接口注入" aria-label="Permalink to &quot;接口注入&quot;">​</a></h6><p><img src="https://raw.githubusercontent.com/aryangzhu/blogImage/master/spring%E6%8E%A5%E5%8F%A3%E6%B3%A8%E5%85%A5.png" alt=""> 这种方式使用较少</p><h6 id="ioc的附加值" tabindex="-1">IOC的附加值 <a class="header-anchor" href="#ioc的附加值" aria-label="Permalink to &quot;IOC的附加值&quot;">​</a></h6><h4 id="掌管大局的ioc-service-provider" tabindex="-1">掌管大局的IoC Service Provider <a class="header-anchor" href="#掌管大局的ioc-service-provider" aria-label="Permalink to &quot;掌管大局的IoC Service Provider&quot;">​</a></h4><p>首先必须明确IoC Service Provider是一个<strong>概念</strong>,它的主要用途就是将业务对象Bean绑定在一起</p><h5 id="ioc-service-provider的职责" tabindex="-1">IoC Service Provider的职责 <a class="header-anchor" href="#ioc-service-provider的职责" aria-label="Permalink to &quot;IoC Service Provider的职责&quot;">​</a></h5><h6 id="业务的创建与管理" tabindex="-1">业务的创建与管理 <a class="header-anchor" href="#业务的创建与管理" aria-label="Permalink to &quot;业务的创建与管理&quot;">​</a></h6><h6 id="业务对象之间的依赖绑定" tabindex="-1">业务对象之间的依赖绑定 <a class="header-anchor" href="#业务对象之间的依赖绑定" aria-label="Permalink to &quot;业务对象之间的依赖绑定&quot;">​</a></h6><p>IoC Service Provider通过结合之前构建和管理的所有业务对象，以及各个业务对象之间可以识别的依赖关系，将这些对象所依赖的对象注入绑定，从而保证每个业务对象的依赖关系。</p><h5 id="ioc-service-provider如何管理对象间的依赖关系" tabindex="-1">IoC Service Provider如何管理对象间的依赖关系 <a class="header-anchor" href="#ioc-service-provider如何管理对象间的依赖关系" aria-label="Permalink to &quot;IoC Service Provider如何管理对象间的依赖关系&quot;">​</a></h5><h6 id="直接编码方式" tabindex="-1">直接编码方式 <a class="header-anchor" href="#直接编码方式" aria-label="Permalink to &quot;直接编码方式&quot;">​</a></h6><h6 id="配置文件" tabindex="-1">配置文件 <a class="header-anchor" href="#配置文件" aria-label="Permalink to &quot;配置文件&quot;">​</a></h6><h6 id="元数据方式" tabindex="-1">元数据方式 <a class="header-anchor" href="#元数据方式" aria-label="Permalink to &quot;元数据方式&quot;">​</a></h6><p>基于java5的注解和Generic的基础上开发的框架。</p><h3 id="spring的ioc容器之beanfactory" tabindex="-1">Spring的IoC容器之BeanFactory <a class="header-anchor" href="#spring的ioc容器之beanfactory" aria-label="Permalink to &quot;Spring的IoC容器之BeanFactory&quot;">​</a></h3><p>BeanFactory和ApplicationContext是有区别的,主要区别就是<strong>BeanFactory主要是IoC Service Provider功能的实现</strong>,而Application承担的更多例如Web场景、Aop场景。</p><h4 id="beanfactory的对象注册和依赖管理" tabindex="-1">BeanFactory的对象注册和依赖管理 <a class="header-anchor" href="#beanfactory的对象注册和依赖管理" aria-label="Permalink to &quot;BeanFactory的对象注册和依赖管理&quot;">​</a></h4><p>既然是IoC Service Provider的实现，那么就需要和IoC Service Provider一样三种实现。</p><h5 id="直接编码方式-1" tabindex="-1">直接编码方式 <a class="header-anchor" href="#直接编码方式-1" aria-label="Permalink to &quot;直接编码方式&quot;">​</a></h5><p>BeanFactory只是一个接口,具体的实现由子类<strong>DefaultListableBeanFactory</strong>来实现,同时DefaultListableBeanFactory又实现了BeanDefinationRegistry接口,该接口才担任Bean组件的注册管理的角色。 <strong>在容器中每一个受管的对象都会有一个BeanDefination实例</strong>,包含了该对象的class类型、是否是抽象类、构造方法等属性。</p><h5 id="外部配置文件" tabindex="-1">外部配置文件 <a class="header-anchor" href="#外部配置文件" aria-label="Permalink to &quot;外部配置文件&quot;">​</a></h5><p>这里以properties文件为例</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">[] args){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    DefaultListableBeanFactory</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> beanRegistry</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> DefaultListableBeanFactory</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    BeanFactory</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> container</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">bindFile</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(beanRegistry);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    FNewsListener</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> fl</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(FNewsListener)container.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getBean</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;djFNewsListener&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    fl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">method</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> BeanFactory </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">bindFile</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(BeanRegistry registry){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    BeanDefinitionReader</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> reader</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> BeanDefinitionReader</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(registry);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    reader.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">loadBeanDefinition</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;classpath:..../../binding-config.properties&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (BeanFactory)registry;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><h5 id="注解方式" tabindex="-1">注解方式 <a class="header-anchor" href="#注解方式" aria-label="Permalink to &quot;注解方式&quot;">​</a></h5><p>@Autowired是最重要的一个注解(也是项目中用的最多的一种方式,虽然书上花费大量篇章去描述XML,奈何大人时代变了)。</p><h5 id="beanfatory的xml-配置文件方式详细" tabindex="-1">BeanFatory的xml(配置文件方式详细) <a class="header-anchor" href="#beanfatory的xml-配置文件方式详细" aria-label="Permalink to &quot;BeanFatory的xml(配置文件方式详细)&quot;">​</a></h5><p>可能作者真的觉得XML配置依赖关系会成为主流,所以才会讲的这么详细</p><h6 id="beans-和-bean" tabindex="-1">&lt;beans&gt;和 &lt;bean&gt; <a class="header-anchor" href="#beans-和-bean" aria-label="Permalink to &quot;\\&lt;beans&gt;和 \\&lt;bean&gt;&quot;">​</a></h6><p>&lt;beans&gt;下面包含许多&lt;bean&gt;,也包含许多属性 例如default-lazy-init、default-autowire、default-dependency-check等等。</p><h6 id="alias-、-description-和-impot" tabindex="-1">&lt;alias&gt;、&lt;description&gt;和&lt;impot&gt; <a class="header-anchor" href="#alias-、-description-和-impot" aria-label="Permalink to &quot;\\&lt;alias&gt;、\\&lt;description&gt;和\\&lt;impot&gt;&quot;">​</a></h6><p>前者是为了起别名</p><div class="language-xml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">alias</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> name</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;dataSourceMasterDataBase&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> alias</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;masterDataSource&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span></code></pre></div><p>&lt;import&gt;是为了导入其他依赖模块</p><h6 id="bean-的属性" tabindex="-1">&lt;bean&gt;的属性 <a class="header-anchor" href="#bean-的属性" aria-label="Permalink to &quot;\\&lt;bean&gt;的属性&quot;">​</a></h6><p><strong>id属性、name属性和class属性</strong> id是bean组件在容器中唯一名称,name属性用来指定别名。 class指定&lt;bean&gt;元素的类型 ,一般来说是必需的。</p><h6 id="xml实现对象间的依赖" tabindex="-1">xml实现对象间的依赖 <a class="header-anchor" href="#xml实现对象间的依赖" aria-label="Permalink to &quot;xml实现对象间的依赖&quot;">​</a></h6><p><strong>构造方法注入</strong></p><div class="language-xml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">constructor-arg</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> index</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;0&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;int&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">&lt;!-- index用来指定第几个位置的参数，type用来指定参数类型 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">ref</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> bean</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;djListener&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">constructor-arg</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span></code></pre></div><p><strong>setter注入</strong></p><div class="language-xml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">property</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">property</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span></code></pre></div><p>&lt;constrcutor&gt;和&lt;property&gt;都能用的配置项(也就是说下面能写什么子元素)</p><ul><li>value</li><li>ref 用来引用容器中其他对象实例 三个属性</li></ul><ol><li>local当前配置文件</li><li>parent 当前容器的父容器中的对象引用</li><li>bean 基本通吃 &lt;idref&gt; 内部&lt;bean&gt; &lt;list&gt; &lt;set&gt;</li><li>depends-on 如果没有ref来指明依赖的话就是用这个属性</li><li>autowire 直接自动绑定依赖,无需在xml中手动编写依赖,和@Autowire注解的功能一致。</li></ol><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> Foo</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    private</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Bar</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  attributeA;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> Bar</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><div class="language-xml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">bean</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;fooBean&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> calss</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;...Foo&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> autowire</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;byType&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">bean</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">bean</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;atrributeA&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> class</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;Bar&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">bean</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span></code></pre></div><p>############ no ############ byName ############ byType ############ constructor ########## dependency-oncheck ########## lazy-init ######## 关于继承 parenet属性 &lt;bean id=&quot;&quot; parent=&quot;&quot;&gt; ######## bean的scope(范围,也就是作用域) ########## singleton 容器中只有一个实例,声明周期一直伴随IoC容器结束。 ########## protype 每次接到该类型对象的请求时，都会重新创建一个对象放回。 ########## request、session和global session web场景下才有 ######## 工厂方法与BeanFactory ########## 静态工厂方法 为什么用工厂？ 有时候需要依赖第三方的库</p><div class="language-xml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">bean</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;foo&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">property</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> name</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;barInterface&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">ref</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> bean</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;bar&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">property</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt; </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">bean</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">bean</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;bar&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> class</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;....Factory&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> factory-method</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;getInstance&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;\\&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">bean</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span></code></pre></div><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> StaticFatoryBean</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  BarInterface </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> BarInterfaceImpl</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>########## 非静态工厂方法(instance Factory Mehod)</p><div class="language-xml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">bean</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;bar&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> factory-bean</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;barFactory&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> factory-method</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;getInstance&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">bean</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span></code></pre></div><p>非静态是以factory-bean属性来指定工厂方法所在的工厂类实例。 ########## FactoryBean 不要和容器名称BeanFactory搞混，FactoryBewan是Spring容器提供的可以扩展容器实例化的接口。 直接看个例子</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> NextDateFactoryBean</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Object </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getObject</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">throws</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Exception{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> DateTime</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">plusDay</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><div class="language-xml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">bean</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;nextDate&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> class</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;NextDateFactoryBean&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">bean</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span></code></pre></div><p>可以和之前的静态方法和非静态方法做个对比 ######## 偷梁换柱之法(修改默认配置) 有的时候声明了protype，但是当从另一个类中getBean()得到的仍然是singleton。 主要是针对prototype(原型)和singleton(单例)的场景做了分析，如果我们需要的是原型应该怎么配置xml。 让我想起了SpringBoot中@Configuration(ProxyBeanMethod=&quot;xxx&quot;)有着异曲同工之妙。 ########## 方法注入 为了解决请求的对象是原型的问题。 方法要求能被子类实现或者是复写,Spring会使用Cglib对方法注入的对象动态生成一个子类实现，从而代替对象。 Spring还有其他的机制来帮我们解决这个问题</p><div class="language-xml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">bean</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;mockPersister&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> class</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;...impl.MockNewsPersister&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">look-up-method</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> name</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;getNewsBean&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;">    bean</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;newsBean&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">     /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">bean</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span></code></pre></div><p>########## BeanFactoryAware接口 只要使用了这个接口，那么在会在当前实例中注入BeanFactory，所以我们就能直接使用BeanFactory.getBean(xxx.class); 这个时候Bean就是原型的。 ########## 方法替换</p><h4 id="容器背后的秘密" tabindex="-1">容器背后的秘密 <a class="header-anchor" href="#容器背后的秘密" aria-label="Permalink to &quot;容器背后的秘密&quot;">​</a></h4><h5 id="ioc容器的两个阶段" tabindex="-1">IoC容器的两个阶段 <a class="header-anchor" href="#ioc容器的两个阶段" aria-label="Permalink to &quot;IoC容器的两个阶段&quot;">​</a></h5><p>下面这个图很重要 <img src="https://raw.githubusercontent.com/aryangzhu/blogImage/master/%E5%AE%B9%E5%99%A8%E5%8A%9F%E8%83%BD%E5%90%84%E4%B8%AA%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%98%B6%E6%AE%B5.png" alt=""></p><h6 id="_1-启动阶段" tabindex="-1">1. 启动阶段 <a class="header-anchor" href="#_1-启动阶段" aria-label="Permalink to &quot;1. 启动阶段&quot;">​</a></h6><p>1.1. 加载配置 加载Configuration Meta 1.2. 分析配置信息 通常是利用BeanDefinitionReader分析 1.3. 装备到BeanDefinition 1.4. 其他后置处理 将BeanDefinition注册到BeanDefinitionRegistry <strong>插手</strong>容器的启动 通过BeanFactoryProcessor接口及其实现类来完成。 试想这样一个场景: 当BeanDefiniation被创建之后如果要对其中的属性进行修改该如何操作(假设有配置生成的Bean)。 BeanFctoryProcessor的一个实现类<strong>BeanFatoryPropertyPlaceholderConfigure</strong>就是将<strong>占位符</strong>\${jdbc.url}这类属性(注意:生成的BeanDefiniton中的jdbcUrl属性还是占位符形式)与配置文件properties中的值进行填入。 BeanFactory的另一个实现类<strong>BeanFactoryPropertyPropertyOverrideConfigure</strong>可以将配置文件中的属性进行替换，这里BeanFactoryPropertyProperyOverrideConfigure有对应的配置文件，可以将Bean里面的属性值替换掉。 <strong>CustomEditorConfigure与自定义PropertyEditor</strong> 从xml中读取出来的都是字符串形式，如何将其转化为一个对象是也是很重要的一项职责。 Spring中提供了很多的propertyEditor来帮助我们完成这一转化。 但是在ApplicationContext的时候，由于Application本身就具有ClassLoader的功能，所以对于Resource类型来说，不用我们自己编写代码。而在BeanFactory中则需要字节编写代码来完成自定义PropertyEditor的职责。</p><h6 id="_2-实例化阶段" tabindex="-1">2. 实例化阶段 <a class="header-anchor" href="#_2-实例化阶段" aria-label="Permalink to &quot;2. 实例化阶段&quot;">​</a></h6><p>对于BeanFactory来说调用getBean()方法或者隐式调用getBean()方法时就会启动。 ApplicationContext则是启动完成就会实例化。 2.1. 实例化对象 检查是否被初始化，如果没有就根据BeanDefinition提供的信息来创建对象实例。 2.2. 装配依赖 注入依赖 2.3. 生命周期回顾 2.4. 对象其他处理 2.5. 注册回调接口 ######## bean的一生(生命周期) ########## Bean的初始化与BeanWrapper 容器内部实例化使用了&quot;策略&quot;模式来决定何种方式初始化bean实例，<strong>可选的策略有反射或者CGlib动态字节码来生成初始化相应的bean实例或者动态生成其子类</strong>。默认情况下，容器内部采用的是CGlibSubClassingInstantiationStrategy。 容器根据<strong>BeanDefinition取得实例化信息</strong>，再加上上面的CGlibSubClassingInstantantiationStrategy(从名字就可以看出生成字节码且是某个类的子类)就可以创建实例。但是，由于返回方式上有些&quot;点缀&quot;，所以不直接返回Bean而是BeanWrapper。 下来的这段话很重要，也表明了为什么需要BeanWrapper的存在。 BeanWrapper实现了实现了PropertyAccessor和TypeConVert接口，所以之前阶段定义的PorpetyEditorRegistry就是这个时候用的，也就是说启动阶段只负责加载了这些玩意儿，而在真正的实例化阶段属性和依赖设置的时候这些才会真正的起作用。 ########## 各色的Aware接口 Aware接口的作用通常是将某个依赖注入到实例中。 BeanNameAware将BeanName添加到当前实例中。 ResourceContextAware将Application添加到当前实例中。 ########## BeanPostFactoryProcessor与BeanFactory 这个阶段常见的就是处理标记接口实现类Aware。 ########## Initical阶段 检查是否初始化 是否有初始化方法 ########## 后置处理 也是Processro机制的一种。</p><h4 id="beanfactory结合xml" tabindex="-1">BeanFactory结合XML <a class="header-anchor" href="#beanfactory结合xml" aria-label="Permalink to &quot;BeanFactory结合XML&quot;">​</a></h4><h3 id="applicationcontext" tabindex="-1">ApplicationContext <a class="header-anchor" href="#applicationcontext" aria-label="Permalink to &quot;ApplicationContext&quot;">​</a></h3><h4 id="统一资源加载策略" tabindex="-1">统一资源加载策略 <a class="header-anchor" href="#统一资源加载策略" aria-label="Permalink to &quot;统一资源加载策略&quot;">​</a></h4><p>URL统一资源定位</p><h5 id="spring中的resource" tabindex="-1">Spring中的Resource <a class="header-anchor" href="#spring中的resource" aria-label="Permalink to &quot;Spring中的Resource&quot;">​</a></h5><p>ByteResource ClassPathResource FileSystemResource ...</p><h5 id="resourceloader" tabindex="-1">ResourceLoader <a class="header-anchor" href="#resourceloader" aria-label="Permalink to &quot;ResourceLoader&quot;">​</a></h5><h6 id="默认实现defalutresourceloader" tabindex="-1">默认实现DefalutResourceLoader <a class="header-anchor" href="#默认实现defalutresourceloader" aria-label="Permalink to &quot;默认实现DefalutResourceLoader&quot;">​</a></h6><p>1.先检查是否以classpath:开头，如果是则使用ClassResource来封装，如果不是跳到2 2.1先判断是否是url形式，如果是的话则使用URLResource封装，如果不是则抛出Exception 2.2前面无法获取资源直接getResourceByPath(String)</p><h6 id="filesytemresourceloader和filesystemxmlresourceloader" tabindex="-1">FileSytemResourceLoader和FileSystemXmlResourceLoader <a class="header-anchor" href="#filesytemresourceloader和filesystemxmlresourceloader" aria-label="Permalink to &quot;FileSytemResourceLoader和FileSystemXmlResourceLoader&quot;">​</a></h6><p>重写了GetResourceByPath()方法 ####### ResourcePatternReslover 批量获得Resource Resource[] getResource(String) ######## 实现类org.springframework.core.io.support.PathMatchingResourcePatternResolover classpath:*/</p><h6 id="applicationcontext与resourceloader" tabindex="-1">ApplicationContext与ResourceLoader <a class="header-anchor" href="#applicationcontext与resourceloader" aria-label="Permalink to &quot;ApplicationContext与ResourceLoader&quot;">​</a></h6><p>首先我们来看下面的图 <img src="https://raw.githubusercontent.com/aryangzhu/blogImage/master/ApplicationContext%E4%B8%8EResourceLoader.png" alt=""> ########## Application扮演ResourceLoader的角色 ########## ResourceLoader类型的注入 这就跟我们之前提到的Aware接口的时候一样 ########## Resource注入 Spring提供了针对Resource类型的PropertyEditor的实现到容器中。 ########## ClassPathXmlApplication和FileSystemXmlApplication 两者的区别就是ClassPathXmlApplication及时pattern没有标明为classpath:,它也会到classpath下去找。 Resource ReosourceLoader ResourceResolver 继承与实现关系 扮演角色 应用场景 其实Resource代表的是资源的抽象,就因为在Java体系的面向对象的思想,很多中间过程也会被设计成类。 Resource有三个实现类,分别是FileSystemResouce、ClassResource和URIResource。 ResourceLoader里面主要的功能就是编写读取资源的策略,根据资源路径的不同传值来将资源封装到不同的类对象中。</p><h3 id="ioc扩展" tabindex="-1">IOC扩展 <a class="header-anchor" href="#ioc扩展" aria-label="Permalink to &quot;IOC扩展&quot;">​</a></h3><h4 id="注解出现之前的xml配置形式" tabindex="-1">注解出现之前的xml配置形式 <a class="header-anchor" href="#注解出现之前的xml配置形式" aria-label="Permalink to &quot;注解出现之前的xml配置形式&quot;">​</a></h4><p>之前管理依赖的时候是在xml中通过</p><div class="language-xml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">bean</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;xxx&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> class</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;xxx&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> autowire</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;byType&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">/&gt;</span></span></code></pre></div><p>自从Java5出现注解之后,Spring框架页顺应时代的发展,有了@Autowired这个注解,从这个时候开始,和现在的项目中的使用已经完全一致了。 但是有了注解之后,必须得有角色来为这个注解服务,还记得之前获取Bean实例的提到的Processor吗,插手容器的启动,对于@Autowired也必须得有一个BeanPostProcessor,spring框架也提供了这样的一个processor 这个时候还没有完全进化成今天这个样子,coder必须得在xml中追加一下配置</p><div class="language-xml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">beans</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">bean</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> class</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;org.springframework.beans.factory.annotations.AutowiredAnnotionBeanPostProcessor&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">bean</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;xxx&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> class</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;xxx&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">beans</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span></code></pre></div><h4 id="注解-autowired和-qulifier" tabindex="-1">注解@Autowired和@Qulifier <a class="header-anchor" href="#注解-autowired和-qulifier" aria-label="Permalink to &quot;注解@Autowired和@Qulifier&quot;">​</a></h4><p>@Autowired有个问题是如果一个类有多个实例,那么Ioc容器就不知道将哪个实例注入给当前对象。 @Qulifier实际上就是byName自动绑定的注解版</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> FXNewsProvider</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Autowired</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Qualifier</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;reutersNewsListener&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    private</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> IFXNewsListener</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> newsListener;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Autowired</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    private</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> IFXNewsPersister</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> newsPersister;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><ol><li>@Autorwired之外的选择-使用JSR250标注依赖注入关系 @Resource使用的是byName的准则同时此注解也需要一个BeanPostProcessor 但是,这样太过于麻烦,所以可以在spring的xml中直接添加&lt;context:annotation-config&gt;</li><li>classpath-scanning 到目前为止,xml中还是配置了bean,但是像@Autowired这类注解又在类中,能不能将其统一掉呢?所以就有了&lt;context:component-scan base-package=&quot;com.changzhu.xxx&quot;&gt;,而且它也完成了&lt;context:annotation-config&gt;的职责,将所有的BeanPostProcessor注入到容器中</li></ol><h2 id="aop部分" tabindex="-1">Aop部分 <a class="header-anchor" href="#aop部分" aria-label="Permalink to &quot;Aop部分&quot;">​</a></h2><h4 id="aop的实现" tabindex="-1">Aop的实现 <a class="header-anchor" href="#aop的实现" aria-label="Permalink to &quot;Aop的实现&quot;">​</a></h4>`,97);function B(s,F,b,m,E,q){const n=h,l=r("ClientOnly");return t(),k("div",null,[C,o(l,null,{default:d(()=>{var i,a;return[(((i=s.$frontmatter)==null?void 0:i.aside)??!0)&&(((a=s.$frontmatter)==null?void 0:a.showArticleMetadata)??!0)?(t(),y(n,{key:0,article:s.$frontmatter},null,8,["article"])):A("",!0)]}),_:1}),D])}const R=p(u,[["render",B]]);export{P as __pageData,R as default};
