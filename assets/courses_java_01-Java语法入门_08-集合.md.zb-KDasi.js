import{_ as s,o as a,c as i,R as t}from"./chunks/framework.FVQzxbLi.js";const A=JSON.parse('{"title":"08-集合","description":"","frontmatter":{"title":"08-集合","author":"Ray","date":"2020/10/02 21:30","categories":["Java生态"],"tags":["Java","Java基础","JDK","开发环境"]},"headers":[],"relativePath":"courses/java/01-Java语法入门/08-集合.md","filePath":"courses/java/01-Java语法入门/08-集合.md","lastUpdated":1743987058000}'),h={name:"courses/java/01-Java语法入门/08-集合.md"},n=t(`<h2 id="java集合框架" tabindex="-1">Java集合框架 <a class="header-anchor" href="#java集合框架" aria-label="Permalink to &quot;Java集合框架&quot;">​</a></h2><p>写这一部分是为了与Guide哥版本的笔记相互辅助参考。下图是集合接口的关系图</p><p><img src="https://raw.githubusercontent.com/rayliu445/blogImage/master/blogImage/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E9%9B%86%E5%90%88%E6%8E%A5%E5%8F%A3%E5%85%B3%E7%B3%BB%E5%9B%BE20250407.jpeg" alt=""></p><h3 id="集合接口与实现分离" tabindex="-1">集合接口与实现分离 <a class="header-anchor" href="#集合接口与实现分离" aria-label="Permalink to &quot;集合接口与实现分离&quot;">​</a></h3><p>Java集合类库将接口与实现进行分离。例如,队列数据结构要求可以在队尾进行插入队头删除元素(FIFO),所以接口应该形如下面:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> Queue</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">E</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;{ </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> add</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(E </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">element</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    E </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">remove</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    E </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getElement</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> size;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>但是,底层实现的时候摆在我们面前的有两个选择:循环数组实现</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> CircularArrayQueue</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">E</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> Queue</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">E</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> first;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> last;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> CircularArrayQueue</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;"> capacity</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){...}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> add</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(E </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">element</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){...}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> E </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">remove</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(){...}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> size</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(){...}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> E</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">[] </span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">elements;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>链表实现</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> LinkedListQueue</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">E</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> Queue</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">E</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    private</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Link</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> head;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    private</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Link</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> tail;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">   	LinkListQueue</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(){...}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> add</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(E </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">element</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){...}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> E </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">remove</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(){...}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> size</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(){...}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>我们在程序中构造时需要考虑哪种具体的类更加符合当下的场景:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Queue</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Customer</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&gt; </span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">queue</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=new</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> CircularArrayQueue&lt;&gt;();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">expressLane.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> Customer</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;Harry&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">));</span></span></code></pre></div><p>API文档中有许多的Abstract开头的类,这是专门为类库实现者而设计的,例如想要实现自己的队列会发现实现AbstractQueue比实现Queue接口轻松得多。</p><h3 id="collection接口" tabindex="-1">Collection接口 <a class="header-anchor" href="#collection接口" aria-label="Permalink to &quot;Collection接口&quot;">​</a></h3><p>这里直接阅读Guide版本。</p><p>##　迭代器</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> Iterator</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">E</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">	E </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    boolean</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> hasNext</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> remove</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    default</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> forEachRemaing</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Consumer&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">?</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> super</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> E</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt; </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">action</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>hasNext方法和next一起使用,Collection扩展了Iterable接口,所以Collection体系下的集合都可以获取一个迭代器。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Colleciton</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">String</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">...; </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Iterator</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&gt; </span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">iter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">c.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">iterator</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">//通过iterator方法来获得迭代器</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(iter.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">hasNext</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">()){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    String</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> next</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">iter.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>**for each(任意实现了Iterable接口的对象)**其实就是迭代器的简单用法(编译器将foreach转换为带迭代器的循环)。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(E</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> e</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> elements){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>Iterable接口</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> Iterable</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">E</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    Iterator&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">E</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">iterator</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>也可以不写循环而是调用forEachRemaing方法并提供一个lambda表达式(作用就是说明如何操作元素)。</p><p>Java中查找集合元素就只有next方法一种,next方法,<strong>迭代器会越过下一个元素,并返回刚刚越过的元素的引用(可以理解为迭代器在两个元素之间)</strong>。</p><p>注意:next方法和remove方法强依赖性</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span>iter.remove();</span></span>
<span class="line"><span>iter.remvoe();//ERROR</span></span>
<span class="line"><span></span></span>
<span class="line"><span>//必须先调用next方法越过元素,才能remove掉刚刚越过的元素</span></span>
<span class="line"><span>iter.remove();</span></span>
<span class="line"><span>iter.next();</span></span>
<span class="line"><span>iter.remove();</span></span></code></pre></div><h3 id="泛型实用方法" tabindex="-1">泛型实用方法 <a class="header-anchor" href="#泛型实用方法" aria-label="Permalink to &quot;泛型实用方法&quot;">​</a></h3><h4 id="常用api" tabindex="-1">常用API <a class="header-anchor" href="#常用api" aria-label="Permalink to &quot;常用API&quot;">​</a></h4><h5 id="java-util-collection-e" tabindex="-1">java.util.Collection&lt;E&gt; <a class="header-anchor" href="#java-util-collection-e" aria-label="Permalink to &quot;java.util.Collection\\&lt;E&gt;&quot;">​</a></h5><h5 id="java-util-iterator-e" tabindex="-1">java.util.Iterator&lt;E&gt; <a class="header-anchor" href="#java-util-iterator-e" aria-label="Permalink to &quot;java.util.Iterator\\&lt;E&gt;&quot;">​</a></h5><h2 id="集合框架中的接口" tabindex="-1">集合框架中的接口 <a class="header-anchor" href="#集合框架中的接口" aria-label="Permalink to &quot;集合框架中的接口&quot;">​</a></h2><h2 id="具体集合" tabindex="-1">具体集合 <a class="header-anchor" href="#具体集合" aria-label="Permalink to &quot;具体集合&quot;">​</a></h2><h3 id="链表" tabindex="-1">链表 <a class="header-anchor" href="#链表" aria-label="Permalink to &quot;链表&quot;">​</a></h3><p>ListIterator实现了Iterator接口,为的是<strong>想在链表表头添加一个元素</strong>。</p><p>书上的LinkedList添加元素的例子很形象:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">List</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Employee</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&gt; </span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">staff</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=new</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> LinkedList&lt;&gt;();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(e1);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(e2);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">ListIterator</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> iter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">listIterator</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">iter.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">iter.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(e3);</span></span></code></pre></div><p>这时迭代器会越过第一个元素e1,将e3添加至表头(也就是说e3在e1后面)。</p><h3 id="数组列表" tabindex="-1">数组列表 <a class="header-anchor" href="#数组列表" aria-label="Permalink to &quot;数组列表&quot;">​</a></h3><p>ArrayList</p><h3 id="散列集" tabindex="-1">散列集 <a class="header-anchor" href="#散列集" aria-label="Permalink to &quot;散列集&quot;">​</a></h3><p>HashSet</p><h3 id="树集" tabindex="-1">树集 <a class="header-anchor" href="#树集" aria-label="Permalink to &quot;树集&quot;">​</a></h3><p>TreeSet</p><h3 id="队列与双端队列" tabindex="-1">队列与双端队列 <a class="header-anchor" href="#队列与双端队列" aria-label="Permalink to &quot;队列与双端队列&quot;">​</a></h3><p>Queue&amp;Deque</p><h3 id="优先队列" tabindex="-1">优先队列 <a class="header-anchor" href="#优先队列" aria-label="Permalink to &quot;优先队列&quot;">​</a></h3><p>PriorityQueue</p><h2 id="映射" tabindex="-1">映射 <a class="header-anchor" href="#映射" aria-label="Permalink to &quot;映射&quot;">​</a></h2><h3 id="基本映射操作" tabindex="-1">基本映射操作 <a class="header-anchor" href="#基本映射操作" aria-label="Permalink to &quot;基本映射操作&quot;">​</a></h3><p>Java类库提供了两个通用的实现:HashMap和TreeMap。这两个类都实现了Map接口。</p><p>map.put();</p><p>map.get(key);</p><h3 id="更新映射条目" tabindex="-1">更新映射条目 <a class="header-anchor" href="#更新映射条目" aria-label="Permalink to &quot;更新映射条目&quot;">​</a></h3><p>map.put();</p><h3 id="映射视图" tabindex="-1">映射视图 <a class="header-anchor" href="#映射视图" aria-label="Permalink to &quot;映射视图&quot;">​</a></h3><p>有3中视图:键集、值集合和键/值对集。</p><h3 id="弱散列映射" tabindex="-1">弱散列映射 <a class="header-anchor" href="#弱散列映射" aria-label="Permalink to &quot;弱散列映射&quot;">​</a></h3><h3 id="枚举集与映射" tabindex="-1">枚举集与映射 <a class="header-anchor" href="#枚举集与映射" aria-label="Permalink to &quot;枚举集与映射&quot;">​</a></h3><p>EnumSet是一个枚举类型元素集和高效实现。由于枚举类型只有有限个实例,所以EnumSet内部用位序列实现。如果对应的值在集中,则相应的位被置为1.</p><h2 id="视图与包装器" tabindex="-1">视图与包装器 <a class="header-anchor" href="#视图与包装器" aria-label="Permalink to &quot;视图与包装器&quot;">​</a></h2><h3 id="小集合" tabindex="-1">小集合 <a class="header-anchor" href="#小集合" aria-label="Permalink to &quot;小集合&quot;">​</a></h3><h3 id="子范围" tabindex="-1">子范围 <a class="header-anchor" href="#子范围" aria-label="Permalink to &quot;子范围&quot;">​</a></h3><h3 id="不可修改的视图" tabindex="-1">不可修改的视图 <a class="header-anchor" href="#不可修改的视图" aria-label="Permalink to &quot;不可修改的视图&quot;">​</a></h3><h3 id="同步视图" tabindex="-1">同步视图 <a class="header-anchor" href="#同步视图" aria-label="Permalink to &quot;同步视图&quot;">​</a></h3><h3 id="检查型视图" tabindex="-1">检查型视图 <a class="header-anchor" href="#检查型视图" aria-label="Permalink to &quot;检查型视图&quot;">​</a></h3><h3 id="关于可选操作的说明" tabindex="-1">关于可选操作的说明 <a class="header-anchor" href="#关于可选操作的说明" aria-label="Permalink to &quot;关于可选操作的说明&quot;">​</a></h3><h2 id="算法" tabindex="-1">算法 <a class="header-anchor" href="#算法" aria-label="Permalink to &quot;算法&quot;">​</a></h2><h3 id="为什么使用泛型算法" tabindex="-1">为什么使用泛型算法 <a class="header-anchor" href="#为什么使用泛型算法" aria-label="Permalink to &quot;为什么使用泛型算法&quot;">​</a></h3><h3 id="排序与混排" tabindex="-1">排序与混排 <a class="header-anchor" href="#排序与混排" aria-label="Permalink to &quot;排序与混排&quot;">​</a></h3><p>书上与Guide的主要区别就是使用了Lambda表达式。</p><h3 id="二分查找" tabindex="-1">二分查找 <a class="header-anchor" href="#二分查找" aria-label="Permalink to &quot;二分查找&quot;">​</a></h3><h3 id="简单算法" tabindex="-1">简单算法 <a class="header-anchor" href="#简单算法" aria-label="Permalink to &quot;简单算法&quot;">​</a></h3><h3 id="批操作" tabindex="-1">批操作 <a class="header-anchor" href="#批操作" aria-label="Permalink to &quot;批操作&quot;">​</a></h3><h3 id="集合与数组的转换" tabindex="-1">集合与数组的转换 <a class="header-anchor" href="#集合与数组的转换" aria-label="Permalink to &quot;集合与数组的转换&quot;">​</a></h3><p>集合转数组list.toArray();</p><p>数组转集合staff.asList();</p><h3 id="编写自己的算法" tabindex="-1">编写自己的算法 <a class="header-anchor" href="#编写自己的算法" aria-label="Permalink to &quot;编写自己的算法&quot;">​</a></h3><h2 id="遗留的集合" tabindex="-1">遗留的集合 <a class="header-anchor" href="#遗留的集合" aria-label="Permalink to &quot;遗留的集合&quot;">​</a></h2><h3 id="hashtable类" tabindex="-1">Hashtable类 <a class="header-anchor" href="#hashtable类" aria-label="Permalink to &quot;Hashtable类&quot;">​</a></h3><h3 id="枚举" tabindex="-1">枚举 <a class="header-anchor" href="#枚举" aria-label="Permalink to &quot;枚举&quot;">​</a></h3><h3 id="属性映射" tabindex="-1">属性映射 <a class="header-anchor" href="#属性映射" aria-label="Permalink to &quot;属性映射&quot;">​</a></h3><h3 id="栈" tabindex="-1">栈 <a class="header-anchor" href="#栈" aria-label="Permalink to &quot;栈&quot;">​</a></h3><h3 id="位集" tabindex="-1">位集 <a class="header-anchor" href="#位集" aria-label="Permalink to &quot;位集&quot;">​</a></h3>`,84),e=[n];function l(p,k,r,d,o,g){return a(),i("div",null,e)}const y=s(h,[["render",l]]);export{A as __pageData,y as default};
