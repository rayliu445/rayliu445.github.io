import{_ as a,o as e,c as t,R as l}from"./chunks/framework.FHZ5yb6k.js";const J=JSON.parse('{"title":"12-Java&JVM点线面","description":"","frontmatter":{"title":"12-Java&JVM点线面","author":"Ray","date":"2020/10/02 21:30","categories":["Java生态"],"tags":["Java","Java基础","JDK","开发环境"]},"headers":[],"relativePath":"courses/java/01-Java语法入门/12-Java&JVM点线面.md","filePath":"courses/java/01-Java语法入门/12-Java&JVM点线面.md","lastUpdated":1742489594000}'),o={name:"courses/java/01-Java语法入门/12-Java&JVM点线面.md"},r=l('<h2 id="java再认知" tabindex="-1">Java再认知 <a class="header-anchor" href="#java再认知" aria-label="Permalink to &quot;Java再认知&quot;">​</a></h2><p>说在开头:主要是从逻辑结构出发而非物理结构,抽象思维也是Java</p><h3 id="面向过程-面向对象" tabindex="-1">面向过程&amp;面向对象 <a class="header-anchor" href="#面向过程-面向对象" aria-label="Permalink to &quot;面向过程&amp;面向对象&quot;">​</a></h3><p>面向过程:注重的是数据的流向 面向对象:关注的是对象之间的交互</p><h3 id="java、c-和c的区别" tabindex="-1">Java、C++和C的区别 <a class="header-anchor" href="#java、c-和c的区别" aria-label="Permalink to &quot;Java、C++和C的区别&quot;">​</a></h3><p>Java和C++都是面向对象 C++和C直接操作计算机系统内存,也就是说资源的释放得我们自己手动来处理。 当然，Java也有手动处理的,但是比C++方便,可以理解为内存之上有个JVM。</p><h4 id="jvm" tabindex="-1">JVM <a class="header-anchor" href="#jvm" aria-label="Permalink to &quot;JVM&quot;">​</a></h4><p>按照黄的讲解，JVM应该是内存一级的，所以才有一次编写,到处运行的特性。</p><h3 id="jvm、jdk、jre" tabindex="-1">JVM、JDK、JRE <a class="header-anchor" href="#jvm、jdk、jre" aria-label="Permalink to &quot;JVM、JDK、JRE&quot;">​</a></h3><p>JVM java虚拟机 JDK java开发工具 JRE java运行环境</p><h4 id="java命令与javac命令" tabindex="-1">java命令与javac命令 <a class="header-anchor" href="#java命令与javac命令" aria-label="Permalink to &quot;java命令与javac命令&quot;">​</a></h4><h2 id="字节码与类的创建过程" tabindex="-1">字节码与类的创建过程 <a class="header-anchor" href="#字节码与类的创建过程" aria-label="Permalink to &quot;字节码与类的创建过程&quot;">​</a></h2><h3 id="从jvm角度出发" tabindex="-1">从JVM角度出发 <a class="header-anchor" href="#从jvm角度出发" aria-label="Permalink to &quot;从JVM角度出发&quot;">​</a></h3><p><img src="https://raw.githubusercontent.com/aryangzhu/blogImage/master/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E2%80%98.jpeg" alt=""> 从图上可以看出,class文件中类型信息(class还是interface,类名)会加载到方法区(逻辑,一个概念),随后会<strong>创建main线程并将其压入线程栈</strong>中(每个线程都有自己的线程栈,也就是说将Hello hello放在线程栈中)。 如果遇到new XXX那么就会创建一个变量，并在堆内存中开辟空间。<strong>对象声明就是对象变量指向对内存中地址</strong></p><h4 id="对象在堆内存中的创建过程" tabindex="-1">对象在堆内存中的创建过程 <a class="header-anchor" href="#对象在堆内存中的创建过程" aria-label="Permalink to &quot;对象在堆内存中的创建过程&quot;">​</a></h4><ol><li>加载实例信息在开辟的内存中</li><li>执行构造方法,即&lt;init&gt;方法</li></ol><h5 id="头部信息" tabindex="-1">头部信息 <a class="header-anchor" href="#头部信息" aria-label="Permalink to &quot;头部信息&quot;">​</a></h5><ol><li>对齐填充</li><li>持有<strong>指向方法区的指针</strong></li><li>描述信息(持有当前对象锁的线程的id和持有对象锁的线程的个数,在gc中存活的生命周期数,偏向锁的标志)</li></ol><h4 id="类的加载过程-将-class文件加载到方法区之前1-5" tabindex="-1">类的加载过程(将.class文件加载到方法区之前1~5) <a class="header-anchor" href="#类的加载过程-将-class文件加载到方法区之前1-5" aria-label="Permalink to &quot;类的加载过程(将.class文件加载到方法区之前1~5)&quot;">​</a></h4><p><img src="https://raw.githubusercontent.com/aryangzhu/blogImage/master/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E5%90%84%E4%B8%AA%E7%8E%AF%E8%8A%82.jpeg" alt=""></p><ol><li>加载:将.class文件通过类加载器加载到内存中</li><li>验证:验证魔数、字节码等是否符合规范</li><li>准备:将类成员初始化为初始值(final变量除外，final变量直接初始化为变量值)</li><li>解析:将常量池中的符号引用替换成直接引用的过程举个例子 hello()方法的地址是123,那么hello()就是符号引用,123就是直接引用</li><li>初始化:将定义的static静态方法和变量组织成&lt;clinit&gt;构造器(也就是3的延伸)</li><li>使用:也就是执行创建实例对象的执行顺序 再来回顾一下,加载实例信息对应的就是上图中的代码块，执行构造方法不必多说</li><li>卸载</li></ol><h4 id="常量池" tabindex="-1">常量池 <a class="header-anchor" href="#常量池" aria-label="Permalink to &quot;常量池&quot;">​</a></h4><p>JVM中以表的形式存在,JVM文件中</p><h2 id="ooa、ood-oop" tabindex="-1">OOA、OOD&amp;OOP <a class="header-anchor" href="#ooa、ood-oop" aria-label="Permalink to &quot;OOA、OOD&amp;OOP&quot;">​</a></h2><p>OOA:面向对象分析 OOD:面向对象设计 OOP:面向对象编程 这节是对前两节内容的强化 问题:为什么static不能访问非static的变量(核心技术卷也没有讲到)</p><h2 id="继承、封装与多态" tabindex="-1">继承、封装与多态 <a class="header-anchor" href="#继承、封装与多态" aria-label="Permalink to &quot;继承、封装与多态&quot;">​</a></h2><p>对于多态的概念有些生疏,刚好借此几乎复习一下</p><h2 id="集合" tabindex="-1">集合 <a class="header-anchor" href="#集合" aria-label="Permalink to &quot;集合&quot;">​</a></h2><h2 id="i-o" tabindex="-1">I/O <a class="header-anchor" href="#i-o" aria-label="Permalink to &quot;I/O&quot;">​</a></h2><h3 id="序列化" tabindex="-1">序列化 <a class="header-anchor" href="#序列化" aria-label="Permalink to &quot;序列化&quot;">​</a></h3><p>将Java对象保存到磁盘 tranisent关键字和Serialiable接口 用途:JSON转换和Tomcat保存Session</p>',31),i=[r];function h(s,n,c,d,u,m){return e(),t("div",null,i)}const p=a(o,[["render",h]]);export{J as __pageData,p as default};
