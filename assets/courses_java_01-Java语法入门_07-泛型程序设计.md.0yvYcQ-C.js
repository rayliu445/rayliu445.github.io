import{_ as s,o as i,c as a,R as n}from"./chunks/framework.FHZ5yb6k.js";const c=JSON.parse('{"title":"07-泛型程序设计","description":"","frontmatter":{"title":"07-泛型程序设计","author":"Ray","date":"2020/10/02 21:30","categories":["Java生态"],"tags":["Java","Java基础","JDK","开发环境"]},"headers":[],"relativePath":"courses/java/01-Java语法入门/07-泛型程序设计.md","filePath":"courses/java/01-Java语法入门/07-泛型程序设计.md","lastUpdated":1745571269000}'),t={name:"courses/java/01-Java语法入门/07-泛型程序设计.md"},h=n(`<p>在没有泛型之前,必须使用Object来编写适用多种类型的代码。泛型类和泛型方法有<strong>类型参数</strong>,使得它们可以准确描述<strong>特定类型实例化</strong>时会发生什么。</p><h2 id="为什么要使用泛型程序设计" tabindex="-1">为什么要使用泛型程序设计 <a class="header-anchor" href="#为什么要使用泛型程序设计" aria-label="Permalink to &quot;为什么要使用泛型程序设计&quot;">​</a></h2><p><strong>泛型程序设计</strong>(generic programming)意味着编写的代码可以被多种不同的类型的对象重用。例如,收集File类型和String类型对象的集合就可以设计为ArrayList&lt;T&gt;。</p><h3 id="_1-类型参数的好处" tabindex="-1">1.类型参数的好处 <a class="header-anchor" href="#_1-类型参数的好处" aria-label="Permalink to &quot;1.类型参数的好处&quot;">​</a></h3><p>在没有泛型之前,实现ArrayList的时候需要在内部<strong>维护</strong>一个Object类型 引用的数组,这种设计很明显是利用了任何类都继承了<strong>Object</strong>类。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> ArrayList</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> Object</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">[] </span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">elementData;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  public</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Object </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;"> i</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">      ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> add</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Object </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">o</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">      ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>这种方式存在两个问题: 1.当获取一个值时必须进行强制类型转换:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> filename</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(String)list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span></code></pre></div><p>2.没有错误检查,可以向数组列表中添加任意类型的对象:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">files.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> File</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;...&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">));</span></span></code></pre></div><p>但是,如果将get的结果进行强制类型转换为String类型,就会产生一个错误。 泛型提供了一个更好的解决方案:<strong>类型参数(type paramater)</strong>。ArrayList类有一个类型用来<strong>指示元素</strong>的类型:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">ArrayList</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&gt; </span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">files</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=new</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> ArrayList&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;();</span></span></code></pre></div><p>java9中对于匿名子类可以使用菱形语法:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">ArrayList</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&gt; </span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">passwords</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=new</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> ArrayList&lt;&gt;(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> 	public</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;"> n</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> super</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(n).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">replaceAll</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;*&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }   </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>编译器也会利用这个类型信息,调用get的时候,<strong>不需要进行强制类型转换</strong>。<strong>编译器</strong>知道返回的类型为String,而不是Object：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> filename</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">files.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span></code></pre></div><p><strong>编译器还会进行检查,防止你插入错误类型的对象</strong>,例如,以下语句:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">files.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> File</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;...&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">));</span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">//can only add Sting objects to an ArrayList&lt;String&gt;</span></span></code></pre></div><p>上面的错误是无法通过编译的。不过,出现<strong>编译错误要比运行时出现类的强制类型转换异常好得多</strong>。</p><h3 id="_2-泛型程序员" tabindex="-1">2.泛型程序员 <a class="header-anchor" href="#_2-泛型程序员" aria-label="Permalink to &quot;2.泛型程序员&quot;">​</a></h3><p>使用泛型类很简单(比较经典的是像ArrayList这样的集合),但是混合使用不同的类型时或者要对类型参数一无所知的遗留代码交互时,你可能看到令人困惑的错误消息,这个时候你需要对Java泛型有足够的了解,才能系统地解决问题。</p><p>应用程序员很可能不会编写太多的泛型代码,因为JDK的编写人员已经尽了自己最大的努力。学习这些知识可以更好地帮助我们来排查错误。</p><h2 id="定义简单泛型类" tabindex="-1">定义简单泛型类 <a class="header-anchor" href="#定义简单泛型类" aria-label="Permalink to &quot;定义简单泛型类&quot;">​</a></h2><p>泛型类就是含多个<strong>类型变量</strong>的类。下面是示例代码</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> Pair</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    private</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> first;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    private</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> second;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> Pair</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        fisrt</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        second</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> Pair</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(T </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">first</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,T </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">second</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.first</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">first;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.second</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">second;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> T </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getFirst</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> first;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> T </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getSecond</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> second;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>引入了一个类型变量T,用&lt;&gt;括起来。泛型类可以有多个类型变量:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> Pair</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">U</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">	...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>其中第一个字段和第二个字段使用不同的类型。</p><p>类型变量在整个类中用于<strong>指定方法的返回类型以及字段和局部变量的类型</strong>。例如:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">private</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> first;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">private</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> T </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getFirst</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(){...}</span></span></code></pre></div><p>可以用具体的类型替换类型变量来**实例化(instance)**泛型类型。</p><p>Pair&lt;String&gt;</p><p>上面所有的T都将被<strong>编译器替换为String(有些工作是需要编译器来完成的,而有些工作在虚拟机中执行)</strong>,换句话说泛型类相当于<strong>普通类的工厂(用于生产普通类)</strong>。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> first</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(String)pair.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getFirst</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span></code></pre></div><h2 id="泛型方法" tabindex="-1">泛型方法 <a class="header-anchor" href="#泛型方法" aria-label="Permalink to &quot;泛型方法&quot;">​</a></h2><p>定义一个带有<strong>类型参数</strong>的方法:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> ArrayAlg</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> &lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt; T </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getMoiddle</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> a[a.length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p><strong>这个方法是定义在普通类中的,而不是在泛型类中</strong>。但是,也可以定义在泛型类中。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> middle</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">ArrayAlg.</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">String</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getMiddle</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;John&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;Q.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;Public&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span></code></pre></div><p>在这种情况下(实际情况下),方法调用可以省略&lt;String&gt;类型参数。编译器有足够的信息推断出你想要的方法。它将参数的类型与泛型类T进行匹配,推断出T一定是String,也就是说上面的代码可以简化为下面的形式。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> middle</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">ArrayAlg.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getMiddle</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;John&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;Q.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;Public&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span></code></pre></div><p>几乎在所有情况下,泛型方法的类型都能正常的工作。但是偶尔也会出现错误:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">double</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> middle</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">ArrayAlg.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getMiddle</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">3.14</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">1729</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span></code></pre></div><p>错误消息将以晦涩的方式指出:解释这个代码有两种方式,且都是合法的。简单的说,编译器将参数自动装箱为1个Double类型对象和2个Integer对象,然后寻找共同的超类型。有两个,一个是Number,一个是Comparable接口。然后,编译器不知道选取哪种类型。解决方法是将所有的参数都写为double值。</p><h2 id="类型变量的限定" tabindex="-1">类型变量的限定 <a class="header-anchor" href="#类型变量的限定" aria-label="Permalink to &quot;类型变量的限定&quot;">​</a></h2><p>有时,类或方法需要对类型变量加以约束。下面的代码用来计算数组中的最小元素:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> ArrayAlg</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> &lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt; T </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">min</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">null</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> ||</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> a.length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">            return</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        T</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> smallest</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">a[</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        for</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">a.length;i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(samllest.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">compareTo</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(a[i]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">)){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">                smallest</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">a[i];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> smallest;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>上面的代码中samllest的类似为T,它可以是任何一个类的对象。</p><p>解决这个问题的办法是限制T只能是实现了Comparable接口(包含一个方法compareTo的标准接口)的类。可以通过对类型变量设置一个**限定(bound)**来实现这一点。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> &lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">T extends Comprable</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> T </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">min</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">[] a)...</span></span></code></pre></div><p>现在,泛型方法min只能在实现Comprable接口的类的数组上调用。</p><p>使用extends是它更接近子类型的概念,限定类型可以是类,也可以是接口。</p><p>一个类型变量或通配符可有多个限定,例如:</p><p>T extends Comparable &amp; Serializable</p><p>限定类型用&quot;&amp;&quot;分隔,而逗号用来分隔类型变量。</p><p>Java继承体系中,可以根据需要拥有多个接口超类型,但<strong>最多有一个限定可以是类</strong>，而且必须是第一个。</p><h2 id="泛型代码和虚拟机" tabindex="-1">泛型代码和虚拟机 <a class="header-anchor" href="#泛型代码和虚拟机" aria-label="Permalink to &quot;泛型代码和虚拟机&quot;">​</a></h2><p><strong>虚拟机中没有泛型类型对象-所有对象都属于普通类</strong>。在泛型实现的早期版本中,甚至能够将使用泛型的程序编译为在1.0虚拟机上运行的类文件。</p><h3 id="类型擦除" tabindex="-1">类型擦除 <a class="header-anchor" href="#类型擦除" aria-label="Permalink to &quot;类型擦除&quot;">​</a></h3><pre><code>无论何时定义一个泛型类型,都会自动提供一个相应的**原始类型(raw type)**。这个原始类型的名字就是去掉类型参数后的泛型类型名。类型变量会被**擦除(erased)**,并替换为其**限定类型**(或者,对于无限定的变量则替换为Object)。
</code></pre><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> Pair</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    private</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Object</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> first;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    private</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Object</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> second;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> Pair</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Object </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">first</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,Object </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">second</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.first</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">first;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.second</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">second;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Object </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getFirst</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> first;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Object </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getSecond</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> second;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> setFirst</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Object </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">newValue</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        first</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">newValue;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> setSecond</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Object </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">newValue</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        second</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">newValue;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><pre><code>**因为T是一个无限定的变量**,所以直接用Object替换。结果是一个普通的类,就和引入泛型之前实现的类一样。

在程序中可以包含不同类型的Pair,例如,Pair\\&lt;String&gt;或Pair\\&lt;LocalDate&gt;。**类型擦除后,它们都会变成原始的类型**。

原始类型用**第一个限定**来替换类型变量,或者,如果没有给定限定,就替换为Object。例如,类Pair\\&lt;T&gt;中的类型变量没有显式的限定,因此,原始类型用Object替换T。
</code></pre><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> Interval</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> extends</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> CXomparable</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> &amp; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Serializable</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> Serializable</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    private</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> lower;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    private</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> upper;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> Interval</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(T </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">first</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,T </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">second</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(first.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">compareTo</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(second)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">            lower</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">first;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">            upper</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">second;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        }</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">            lower</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">second;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">            upper</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">first;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>原始类型Interval如下所示:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Interval implements Serializable{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    private</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Comparable</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> lower;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    private</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Comparable</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> upper;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">   	public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> Interval</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Comparable first,Comparable second){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>如果限定时将Serializable接口放在前面,那么原始类型就会用Serializable接口替换T,而编译器在必要时要向Comparable插入强制类型转换。为了提高效率,应该将**标签接口(即没有方法的接口)**放在限定列表的末尾。</p><h3 id="转换泛型表达式" tabindex="-1">转换泛型表达式 <a class="header-anchor" href="#转换泛型表达式" aria-label="Permalink to &quot;转换泛型表达式&quot;">​</a></h3><p>编写一个泛型方法调用时,如果擦除了返回类型,编译器会插入强制类型转换。例如:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Pair</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Employee</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&gt; </span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">buddies</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">...;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Employee</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> first</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">buddies.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getFirst</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span></code></pre></div><p><strong>getFirst擦除之后的返回类型是Object。编译器自动插入转换到Employee的强制类型转换</strong>。也就是说,编译器把这个方法调用转换为两条虚拟机指令:</p><p>1.对原始方法Pair.getFirst的调用;</p><p>2.将返回的Object类型强制转换为Employee类型。</p><p>当访问一个泛型字段时也要插入强制类型转换。例如</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Employee</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> buddy</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">buddies.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getFirst</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span></code></pre></div><p>也会在结果字节码中插入强制类型转换。</p><h3 id="转换泛型方法" tabindex="-1">转换泛型方法 <a class="header-anchor" href="#转换泛型方法" aria-label="Permalink to &quot;转换泛型方法&quot;">​</a></h3><p>类型擦除也会出现在泛型方法中。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> &lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">T extends Comparable</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> T </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">min</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">[] a){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>是整个一组方法,而擦除类型之后,只剩下一个方法:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Comparable </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">min</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Comparable</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">[] a)</span></span></code></pre></div><p>方法的擦除带来了两个复杂的问题,先来看下面的代码:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> DateInterval</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> Pair</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">LocalDate</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> setSecond</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(LocalDate </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">second</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(second.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">compareTo</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getFirst</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">())</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">            super</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.setSecond;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>1.日期区间是一对LocalDate对象,而且我们需要覆盖这个方法来确保第二个值永远不小于第一个值。</p><p>类型擦除之后应该如下:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> DataInterval</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> Pair</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">	public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> setSecond</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(LocalDate </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">second</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>但是还有另一个从Pair继承的setSecond方法,即</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> setSecond</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">((Object second)</span></span></code></pre></div><p>2.很明显,不是同一个方法,因为它有一个类型不同的参数-Object,而不是LocalDate。不过,不应该不一样:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> interval</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> DateInterval</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(...);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Pair</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">LocalDate</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&gt; </span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">pair</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">interval;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">pair.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">setSecond</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(aDate);</span></span></code></pre></div><p>上面的代码中,由于pair引用了一个DateInterval对象,我们希望setSecond调用具有多态性去调用最合适的方法,所以应该调用的是DateInterval.setSecond方法。</p><p>为了解决这个问题,<strong>编译器在DateInterval类中</strong>生成了一个<strong>桥方法</strong>(bridge method)：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> setSecond</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Object second){</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">    setSecond</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">setSecond</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(LocalDate) second);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>对pair.setSecond(aDate)进行跟踪:</p><p>变量pair已经声明为类型Pair&lt;LocalDate&gt;,类中只有一个setSecond方法即setSecond(Object object)。虚拟机子在pair引用的对象上调用这个方法。这个对象是<strong>DateInterval类型</strong>,因而将会调用DateInterval.setSecond(Object)方法。这个方法是合成的桥方法,它会调用DateInterval。setSecond(LocalDate),正是我们需要的。</p><p>假设DateInterval类也覆盖了getSecond方法:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> DateInterval</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> Pair</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">LocalDate</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> LocalDate </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getSecond</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (LocalDate)</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">super</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getSecond</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>那么在DateInterval类中,有两个getSecond方法:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">LocalDate </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getSecond</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">//defined in DateInterval</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Object </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getSecond</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">//overrides the method defined in Piar to call the first method</span></span></code></pre></div><p>java中不允许两个方法有相同的类型参数。但是,<strong>会由参数类型和返回类型共同指定一个方法</strong>。因此,编译器会为两个仅返回类型不同的方法生成字节码,虚拟机能够正确地处理这种情况。</p><p>对于Java泛型的转换,需要记住以下几点:</p><p>1.虚拟机中没有泛型,只有普通的类和方法;</p><p>2.所有的类型参数都会替换为它们的限定类型;</p><p>3.会合成桥方法来保持多态;</p><p>4.为保持类型安全性,必要时会插入强制类型转换。</p><h3 id="调用遗留代码" tabindex="-1">调用遗留代码 <a class="header-anchor" href="#调用遗留代码" aria-label="Permalink to &quot;调用遗留代码&quot;">​</a></h3><p>可以使用<strong>注解</strong>(annotation)来让警告消失,如下:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">SuppressWarnings</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;uncheked&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Dictionary</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Integer</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Components</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&gt; </span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">labelTable</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">slider.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getLabelTable</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span></code></pre></div><h2 id="限制与局限性" tabindex="-1">限制与局限性 <a class="header-anchor" href="#限制与局限性" aria-label="Permalink to &quot;限制与局限性&quot;">​</a></h2><p>大多数限制都是由类型擦除引起的。</p><h3 id="_1-不能用基本类型" tabindex="-1">1.不能用基本类型 <a class="header-anchor" href="#_1-不能用基本类型" aria-label="Permalink to &quot;1.不能用基本类型&quot;">​</a></h3><p>例如,没有Pair&lt;double&gt;,因为擦除之后类型变量变为Oject类型,而Object不能存储double值。</p><h3 id="_2-运行时类型查询只适用于原始类型" tabindex="-1">2.运行时类型查询只适用于原始类型 <a class="header-anchor" href="#_2-运行时类型查询只适用于原始类型" aria-label="Permalink to &quot;2.运行时类型查询只适用于原始类型&quot;">​</a></h3><p><strong>虚拟机中的对象总有一个特定的非泛型类型</strong>。因此,所有的类型查询只产生原始类型。例如,</p><p>if(a instanceof Pair&lt;String&gt;) //ERROR</p><p>if(a instanceof Pair&lt;T&gt;) //ERROR</p><p>或者强制类型转换:</p><p>Pair&lt;String&gt; p=(Pair&lt;String&gt;) a;//warning-can only test that a is a Pair;</p><p>同样的道理,getClass方法总是返回原始类型。例如:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Pair</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&gt; </span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">stringPair</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">...;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Pair</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Employee</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&gt; </span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">employeePair</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">...;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(stringPair.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getClass</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">employeePair.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getClass</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">())</span></span></code></pre></div><p>返回的结果是true,两次调用的结果都返回Pair.clss。</p><h3 id="_3-不能创建参数类型的数组" tabindex="-1">3.不能创建参数类型的数组 <a class="header-anchor" href="#_3-不能创建参数类型的数组" aria-label="Permalink to &quot;3.不能创建参数类型的数组&quot;">​</a></h3><p>不能实例化参数化类型的数组,例如:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> table</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=new</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Pair&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Sting</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;[</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">]; </span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">//ERROR</span></span></code></pre></div><p>这有什么问题呢?擦除之后，table的类型是Pair[],可以将其转换为Object[]：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span>Object[] objarray=table;</span></span></code></pre></div><p>数组会记住元素类型,如果视图存储其他类型的元素,就会抛出一个ArrayStoreException异常。</p><p>objarray[0]=&quot;Hello&quot;; //ERROR</p><h3 id="_4-varargs警告" tabindex="-1">4.Varargs警告 <a class="header-anchor" href="#_4-varargs警告" aria-label="Permalink to &quot;4.Varargs警告&quot;">​</a></h3><p>场景:向参数可变的方法传递一个泛型类型的实例。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> &lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> addAll</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Collection</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> coll,T...ts){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(T</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> t</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">ts){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        coll.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(t);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p><strong>实际上参数ts是一个数组,包含提供的所有实参</strong>。</p><p>考虑以下调用:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Collection</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Pair</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&gt;&gt; </span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">table</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">...;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Pair</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&gt; </span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">pair1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">...;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Pair</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&gt; </span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">pair2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">...;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">addAll</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(table,pair1,pair2);</span></span></code></pre></div><p>为了调用这个方法,Java虚拟机必须建立一个Pair&lt;String&gt;数组,这就违反了前面的规则。</p><h3 id="_5-不能实例化类型变量" tabindex="-1">5.不能实例化类型变量 <a class="header-anchor" href="#_5-不能实例化类型变量" aria-label="Permalink to &quot;5.不能实例化类型变量&quot;">​</a></h3><p>不能使用类似new T(...)的表达式。</p><p>类型擦除变为Object,我们不需要Object。</p><p>Java8之后,最好的解决办法是让调用者提供一个构造器表达式。例如:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Pair</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&gt; </span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">p</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Pair.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">makePair</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(String</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">::new</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span></code></pre></div><p>makePair方法接收一个<strong>Supplier&lt;T&gt;，这是一个函数式接口</strong>,表示一个无参数而且返回类型为T的函数:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> &lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Pair</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> makePair</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Supplier</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> constr){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Pair&lt;&gt;(constr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(),constr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">());</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>传统的方式通过反射调用Constructor.newInstance方法来构造泛型对象:</p><p>first=T.class.getConstructor().newInstance(); //ERROR</p><p>表达式T.class是不合法的,擦除之后会变为Object.class。</p><p>我们自己来编写API</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> &lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Pair</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> makePair</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Class</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> cl){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    try</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Pair&lt;&gt;(cl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getConstructor</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">newInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        cl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getConstructor</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">newInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">());</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Exception </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>如下调用:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Pair</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&gt; </span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">p</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Pair.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">makePair</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(String.class);</span></span></code></pre></div><p>String.class是一个Class&lt;String&gt;的实例(事实上,它是唯一的实例)。因此,makePair方法能够推断出所建立的对组(pair)的实例。</p><h3 id="_6-不能构造泛型数组" tabindex="-1">6.不能构造泛型数组 <a class="header-anchor" href="#_6-不能构造泛型数组" aria-label="Permalink to &quot;6.不能构造泛型数组&quot;">​</a></h3><p>擦除之后可能在类型转换出现ClassCastException。</p><h3 id="_7-泛型类的静态上下文中类型变量无效" tabindex="-1">7.泛型类的静态上下文中类型变量无效 <a class="header-anchor" href="#_7-泛型类的静态上下文中类型变量无效" aria-label="Permalink to &quot;7.泛型类的静态上下文中类型变量无效&quot;">​</a></h3><p>不能在静态字段或方法中引用类型变量。</p><h3 id="_8-不能抛出或捕获泛型类的实例" tabindex="-1">8.不能抛出或捕获泛型类的实例 <a class="header-anchor" href="#_8-不能抛出或捕获泛型类的实例" aria-label="Permalink to &quot;8.不能抛出或捕获泛型类的实例&quot;">​</a></h3><p>既不能拼抛出也不能捕获泛型类的对象,泛型类扩展Throwable甚至都是不合法的。</p><h3 id="_9-可以取消对检查型异常的检查" tabindex="-1">9.可以取消对检查型异常的检查 <a class="header-anchor" href="#_9-可以取消对检查型异常的检查" aria-label="Permalink to &quot;9.可以取消对检查型异常的检查&quot;">​</a></h3><h3 id="_10-注意擦除后的冲突" tabindex="-1">10.注意擦除后的冲突 <a class="header-anchor" href="#_10-注意擦除后的冲突" aria-label="Permalink to &quot;10.注意擦除后的冲突&quot;">​</a></h3><p>这里需要注意与Object类的方法发生冲突。</p><h2 id="泛型类型的继承规则" tabindex="-1">泛型类型的继承规则 <a class="header-anchor" href="#泛型类型的继承规则" aria-label="Permalink to &quot;泛型类型的继承规则&quot;">​</a></h2><p>下面的代码将不能编译:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Manager</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">[] </span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">topHonchos</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">...;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Pair</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Employee</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&gt; </span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">result</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">ArrayAlg.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">minmax</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(topHonchos);</span></span></code></pre></div><p>minmax方法返回Pair&lt;Manager&gt;而不是Pair&lt;Employee&gt;,并且这样的赋值是不合法的。</p><p>通过下面这个图可以直观的看出继承规则:</p><p><img src="https://gitee.com/aryangzhu/picture/raw/master/java/%E6%B3%9B%E5%9E%8B%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E8%A7%84%E5%88%99.jpg" alt=""></p><p>注:上面的就是泛型类型与Java数组之间的一个重要区别。<strong>可以将一个Manager[]数组赋给一个类型为Employee[]的变量</strong>:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Manager</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">[] </span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">managerBuddies</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{ceo,cfo};</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Employee</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">[] </span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">employeeBuddies</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">managerBuddies;</span></span></code></pre></div><p>如果试图将一个低级别的员工存储到employeeBuddies[0],虚拟机将会抛出ArrayStoreException异常。</p><p>总是可以将<strong>参数类型(泛型类型)转换为一个原始类型</strong>。例如,Pair&lt;Employee&gt;是原始类型Pair的子类型。但是<strong>转换成原始类型会产生错误</strong>。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Pair</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Manager</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&gt; </span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">managerBuddies</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=new</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Pair&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Manager</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;(ceo,cfo);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Pair</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> rawBuddies</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">managerBuddies;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">rawBuddies.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">setFirst</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> File</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;...&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">//only a complie-time warning</span></span></code></pre></div><p><img src="https://gitee.com/aryangzhu/picture/raw/master/java/%E6%B3%9B%E5%9E%8B%E5%88%97%E8%A1%A8%E7%B1%BB%E5%9E%8B%E4%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%B3%E7%B3%BB.jpg" alt=""></p><p><strong>泛型类可以扩展或者实现其他的泛型类</strong>。例如,ArrayList&lt;T&gt;类实现了List接口。这意味着,一个ArrayList&lt;Manager&gt;可以转换为一个List&lt;Manager&gt;。</p><h2 id="通配符" tabindex="-1">通配符 <a class="header-anchor" href="#通配符" aria-label="Permalink to &quot;通配符&quot;">​</a></h2><h3 id="通配符概念" tabindex="-1">通配符概念 <a class="header-anchor" href="#通配符概念" aria-label="Permalink to &quot;通配符概念&quot;">​</a></h3><p>通配符类型中,允许参数发生变化。例如,通配符类型</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Pair</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;?</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> extends Employee</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span></span></code></pre></div><p>表示<strong>任何(这里的任何指的是一个集合)泛型Pair类型</strong>。它的类型参数是Employee的子类,如Pair&lt;Manager&gt;。</p><p>来看下面的代码:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> printBuddies</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Pair</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Employee</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> p){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    Employee</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> first</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">p.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getFirst</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    Employee</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> second</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">p.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getSecond</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(first.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getName</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;and &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">second.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getName</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;are buddies&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>我们知道不能将Pair&lt;Manager&gt;传递给这个方法,但是我们可以解决这个问题:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> printBuddies</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Pair</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;?</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> extends Empooyee</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> p)</span></span></code></pre></div><p>类型Pair&lt;Manager&gt;是Pair&lt;? extends Employee&gt; p)的子类型。</p><p>来看下面的代码:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Pair</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Manager</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&gt; </span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">managerBuddies</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=new</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Pair&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Manager</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;(ceo,cfo);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Pair</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">?</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> extends</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> Employee</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&gt; </span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">wildcardBuddies</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">managerBuddies;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">wildcardBuddies.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">setFirst</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(lowEmployee); </span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">//complie-time error</span></span></code></pre></div><p>我们担心的是破坏掉Pair&lt;Manager&gt;的引用,但是显然不会,原因是:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> extends Employee </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getFirst</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> setFirst</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> extends Employee)</span></span></code></pre></div><p>编译器知道？是Employee的子类型,但是不知道具体是什么类型,它就<strong>拒绝传递任何特定的类型</strong>。？不能匹配。</p><p>使用getFirst就不存在这个问题:将getFirst的返回值赋给一个Employee引用完全是合法的。</p><p><strong>这就是引入有限定的通配符的关键之处</strong>。到这里,已经有了安全的访问器方法和不安全的更改器方法。</p><h3 id="通配符的超类限定" tabindex="-1">通配符的超类限定 <a class="header-anchor" href="#通配符的超类限定" aria-label="Permalink to &quot;通配符的超类限定&quot;">​</a></h3><p>通配符限定与类型变量限定十分类似,但是,还有一个附加的能力,即可以指定一个<strong>类型限定</strong>(supertype bound),如下:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">?</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> super</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Manager</span></span></code></pre></div><p>这个通配符限制为Manager的所有超类型。</p><p><strong>直观来讲,带有超类型限定的通配符允许你写入一个泛型对象,而带有子类型限定的通配符允许你读取一个泛型对象</strong>。</p><p>第一个经典示例:我们来求一个经理数组中的最大奖金和最小奖金,很明显,Manager可以,Employee也可以:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> minmax</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Manager</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">[] a,Pair</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;?</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> super</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Manager</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> result){</span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">//第二个参数代表Manager或者Manager的超类Employee</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(a.length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    Manager</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> min</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">a[</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    Manafer</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> max</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">a[</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>来看一个应用:Comparable接口本身就是一个泛型类型。声明如下:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> Comparable</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> compareTo</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(T </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">other</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>String实现了Comparable&lt;String&gt;,它的compareTo方法声明为:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> compareTo</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(String other)</span></span></code></pre></div><p>由于Comparable是一个泛型类型,也许可以把ArrayAlg类的min方法做得更好:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> &lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">T extends Comparable</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> T </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">min</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">[] a)</span></span></code></pre></div><p>使用minmax方法处理一个LocalDate对象的数组时,我们会遇到一个问题。LocalDate实现了ChronoLocalDate,而ChronoLocalDate扩展了Comparble&lt;ChronoLocalDate&gt;,因此LocalDate实现的是Comparable&lt;ChronoLocalDate&gt;而不是Comparable&lt;LocalDate&gt;.</p><p>在这种情况下,可以利用超类型来解决:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> &lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">T extends Comparable</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;?</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> super</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> T </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">min</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">[] a)...</span></span></code></pre></div><p>compraeTo方法写成</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> compareTo</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">?</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> super</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> T)</span></span></code></pre></div><p>他可以声明使用类型T的对象,或者也可以是使用T的一个超类型的对象(当T是LocalDate时)。</p><p>作为库程序员,你有必要慢下来仔细理解其中的逻辑,但是工作中只需要了解即可。</p><h3 id="无限定通配符" tabindex="-1">无限定通配符 <a class="header-anchor" href="#无限定通配符" aria-label="Permalink to &quot;无限定通配符&quot;">​</a></h3><p>形如Pair&lt;?&gt;</p><p>? getFirst()</p><p>void setFirst(?)</p><p>getFirst的返回值只能赋给一个<strong>Object</strong>。setFirst方法不能被调用,<strong>甚至不能用Object</strong>调用。Pair&lt;?&gt;和Pair本质的不同在于:<strong>可以用任意Object对象调用原始Piar类的setFirst方法</strong>。</p><h3 id="通配符捕获" tabindex="-1">通配符捕获 <a class="header-anchor" href="#通配符捕获" aria-label="Permalink to &quot;通配符捕获&quot;">​</a></h3><p>我们来看一个例子,用一个方法来交换对组的元素:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> swap</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Pair</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> p)</span></span></code></pre></div><p><strong>通配符不是类型变量</strong>,因此,不能在编写代码中使用&quot;?&quot;作为一种类型。也就是说,下面的代码是非法的:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> t</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">p.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getFirst</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">//ERROR</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">p.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">setFirst</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(p.getSecond);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">p.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">setSecond</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(t);</span></span></code></pre></div><p>为了解决这个问题,我们可以编写一个辅助方法swapHelper,如下所示:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> &lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> swap</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Piar</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> p){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    T</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> t</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">p.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getFirst</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    p.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">setFirst</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(p.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getSecond</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">());</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    p.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">setSecond</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(t);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>注意:swapHelper是一个泛型方法,而swap不是,它有一个固定的Pair&lt;?&gt;类型的参数。</p><p>swapHelper方法的参数T<strong>捕获通配符</strong>。它不知道通配符指示哪种类型,但是,这是<strong>一个明确的类型</strong>,并且从&lt;T&gt;swapHelper的定义可以清楚地看到T指示这个类型。</p><p>通配符捕获只有非常限定的情况下才是合法的。编译器必须能够保证通配符表示单个确定的类型。例如,ArrayList&lt;Pair&lt;T&gt;&gt;中的T永远不能捕获ArrayList&lt;Pair&lt;?&gt;&gt;中的通配符。数组列表可以保存两个Pair&lt;?&gt;,其中的？分别具有不同的类型。</p><p>#　反射和泛型</p><p>反射允许你在运行时分析任意对象。</p><h3 id="泛型class类" tabindex="-1">泛型Class类 <a class="header-anchor" href="#泛型class类" aria-label="Permalink to &quot;泛型Class类&quot;">​</a></h3><p>现在,Class类是泛型的。例如,<strong>String.class实际上是一个Class&lt;String&gt;类的对象</strong>(事实上,这是唯一的对象)。</p><p>类型参数十分有用,这是因为它<strong>允许Class&lt;T&gt;方法的返回类型更加具有特定性</strong>。</p><p>以下方法就使用了类型参数:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">T </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> Instance</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">T cast(Object obj)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">[] </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getEnumConstants</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Class </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;?</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> super</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> getSuperClass</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Constructor</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> getConstructor</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Class...parameterTypes)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Constructor</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> getDeclareConstructor</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Class...paramaterTypes)</span></span></code></pre></div><p>newInstance方法返回这个类的一个实例,由无参数构造器获得。<strong>它的返回类型现在被声明为T,其类型与Class&lt;T&gt;描述的类相同</strong>,这样就避免了类型转换。</p><p>如果给定对象的类型实际上是T的一个子类型,cast方法就会返回这个给定对象(现在声明为类型T),否则,会抛出一个BadCastException异常。</p><p>getConstructor和getdeclaredConstructor方法返回一个Constructor&lt;T&gt;对象。Constructor类也已经变成泛型,从而使newInstance方法有一个正确的返回类型。</p><h3 id="常用api" tabindex="-1">常用API <a class="header-anchor" href="#常用api" aria-label="Permalink to &quot;常用API&quot;">​</a></h3><h4 id="java-lang-class-t" tabindex="-1">java.lang.Class&lt;T&gt; <a class="header-anchor" href="#java-lang-class-t" aria-label="Permalink to &quot;java.lang.Class\\&lt;T&gt;&quot;">​</a></h4><h5 id="t-newinstance" tabindex="-1">T newInstance <a class="header-anchor" href="#t-newinstance" aria-label="Permalink to &quot;T newInstance&quot;">​</a></h5><p>返回无参数构造器构造的一个新实例。</p><h5 id="t-cast-object-obj" tabindex="-1">T cast(Object obj) <a class="header-anchor" href="#t-cast-object-obj" aria-label="Permalink to &quot;T cast(Object obj)&quot;">​</a></h5><p>如果obj为null或有可能转换为类型T,则返回obj;否则抛出一个BadCastException异常。</p><h5 id="t-getenumconstants" tabindex="-1">T[] getEnumConstants() <a class="header-anchor" href="#t-getenumconstants" aria-label="Permalink to &quot;T[] getEnumConstants()&quot;">​</a></h5><p>如果T是枚举类型,则返回所有数组值组成的数组,范泽返回null。</p><h5 id="class-super-t-getsuperclass" tabindex="-1">Class&lt;? super T&gt; getSuperClass() <a class="header-anchor" href="#class-super-t-getsuperclass" aria-label="Permalink to &quot;Class\\&lt;? super T&gt; getSuperClass()&quot;">​</a></h5><p>返回这个类的超类。如果T是一个类或Object类,则返回null。</p><h5 id="constructor-t-getconstructor-class-paramatertypes" tabindex="-1">Constructor&lt;T&gt; getConstructor(Class paramaterTypes) <a class="header-anchor" href="#constructor-t-getconstructor-class-paramatertypes" aria-label="Permalink to &quot;Constructor\\&lt;T&gt; getConstructor(Class paramaterTypes)&quot;">​</a></h5><h5 id="constructor-t-getdeclaredconstructor-class-paramatertypes" tabindex="-1">Constructor&lt;T&gt; getDeclaredConstructor(Class paramaterTypes) <a class="header-anchor" href="#constructor-t-getdeclaredconstructor-class-paramatertypes" aria-label="Permalink to &quot;Constructor\\&lt;T&gt; getDeclaredConstructor(Class paramaterTypes)&quot;">​</a></h5><p>获得公共构造器,或者有给定参数类型的构造器。</p><h4 id="java-lang-reflect-constructor-t" tabindex="-1">java.lang.reflect.Constructor&lt;T&gt; <a class="header-anchor" href="#java-lang-reflect-constructor-t" aria-label="Permalink to &quot;java.lang.reflect.Constructor\\&lt;T&gt;&quot;">​</a></h4><h5 id="t-newinstance-object-paramaters" tabindex="-1">T newInstance(Object...paramaters) <a class="header-anchor" href="#t-newinstance-object-paramaters" aria-label="Permalink to &quot;T newInstance(Object...paramaters)&quot;">​</a></h5><p>返回用指定参数构造的新实例。</p><h3 id="使用class-t-参数进行类型匹配" tabindex="-1">使用Class&lt;T&gt;参数进行类型匹配 <a class="header-anchor" href="#使用class-t-参数进行类型匹配" aria-label="Permalink to &quot;使用Class\\&lt;T&gt;参数进行类型匹配&quot;">​</a></h3><p>匹配泛型方法中Class&lt;T&gt;参数的类型变量有时会很有用。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> &lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Pair</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> makePair</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Class</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> c) throws InstantiationException,IllegalAccessException{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Pair&lt;&gt;(c.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">newInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(),c.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">newInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">());</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>如果调用</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">makePair</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Employee.class)</span></span></code></pre></div><p>Employee.class将是一个Class&lt;Employee&gt;类型的对象。makePair方法的类型参数T同Employee匹配,编译器可以推断出这个方法返回一个Pair&lt;Employee&gt;。</p><h3 id="虚拟机中的泛型类型参数" tabindex="-1">虚拟机中的泛型类型参数 <a class="header-anchor" href="#虚拟机中的泛型类型参数" aria-label="Permalink to &quot;虚拟机中的泛型类型参数&quot;">​</a></h3><p>Java泛型的突出特性之一就是在<strong>虚拟机中擦除泛型类型</strong>。但是,擦除的类好像仍然会保存原先泛型的微弱记忆。例如,原始的Pair类知道它源于泛型类Pair&lt;T&gt;,尽管一个Pair类型的对象无法区分它是构造为Pair&lt;String&gt;还是Pair&lt;Employee&gt;.</p><p>类似的,考虑以下方法:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Comparable </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">min</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Comparable</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">[] a)</span></span></code></pre></div><p>这是擦除以下方法得到的:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> &lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">T extends Comparable</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;?</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> super</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> T </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">min</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">[] a)</span></span></code></pre></div><p>可以使用反射API来确定与类型声明有关的参数,<strong>java.lang.reflect</strong>包中的接口<strong>Type</strong>。这个接口包含了以下子类型:</p><p>1.Class类,描述<strong>具体类型</strong>。</p><p>2.TypeVariable接口,描述<strong>变量类型</strong>(如T extends Comparable&lt;? super T&gt;)。</p><p>3.WildcardType接口,描述<strong>通配符</strong>(如? super T)。</p><p>4.ParameterType接口,描述<strong>泛型类或接口类型</strong>(如Comparable &lt;? super T&gt;)。</p><p>5.GenericArrayType接口,描述<strong>泛型数组</strong>(如T[])。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> GenericReflectionTest</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        String</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> name;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        try</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Scanner</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> in</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> Scanner</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(System.in)){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">            ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">            name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">in.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">            ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        try</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">            Class</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">&gt; </span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">cl</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Class.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">forName</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(name);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">            printClass</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(cl);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">            for</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Method</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> m</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">cl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getDeclareMethods</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">()){</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">                printMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(m);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        }</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(ClassNotFoundException </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">            e.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">printStackTrace</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> printClass</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Class&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt; </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">cl</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">       	Type</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> sc</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">cl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getGenericSuperClass</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(sc</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">            ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> printMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Method </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">m</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        String</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">m.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getName</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> printTypes</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Type</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">types</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,String </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">pre</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,String </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">sep</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,String </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">suf</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">boolean</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;"> isDefinition</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">     	if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(pre.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">equals</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;extends&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Arrays.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">equals</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(types,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">new</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> Type</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">[]{Object.class})){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">            return</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">      	if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(types.length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">            ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        for</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">types.length;i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">                ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">            }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">            printTypes</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(types[i],isDefinition);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(types.length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">           ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">   </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> printType</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(Type </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">type</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">boolean</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;"> isDefinition</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><h3 id="类型字面量" tabindex="-1">类型字面量 <a class="header-anchor" href="#类型字面量" aria-label="Permalink to &quot;类型字面量&quot;">​</a></h3><p>先来看例子,在一种持久存储机制中,你可能希望用户指定一种方法来保存某个特定类的对象。但是,既然ArrayList&lt;Integer&gt;和ArrayList&lt;Double&gt;都会被擦除为同一个原始类类型ArrayList,如何让它们具有不同的动作呢?</p><p>我们可以将泛型类与Type接口进行结合。如下:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=new</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> TypeLiteral&lt;ArrayList&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">Integer</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;&gt;(){};</span></span></code></pre></div><p>TypeLiteral构造器会捕获泛型超类型:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> TypeLiteral</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> TypeLiteral</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        Type</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> parentType</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getClass</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getGenericSuperClass</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(parentType instancof ParameterizedType){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">            type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(ParameterizedType)parentType.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getActualTypeArguments</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">()[</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        else</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">            throw</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> UnsupportedOperationException</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;Construct as new TypeLiteral&lt;...&gt;(){}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>如果运行时有一个泛型类型,就可以将它与TypeLiteral匹配。我们无法从一个对象得到泛型类型(已经被擦除)。但是,<strong>字段和方法参数的泛型类型还留在虚拟机中</strong>。</p><p>**CDI和Guice等注入框架(Injection framework)**就是使用类型字面量来控制泛型类型的注入。</p><h4 id="常用api-1" tabindex="-1">常用API <a class="header-anchor" href="#常用api-1" aria-label="Permalink to &quot;常用API&quot;">​</a></h4><h5 id="java-lang-class-t-1" tabindex="-1">java.lang.Class&lt;T&gt; <a class="header-anchor" href="#java-lang-class-t-1" aria-label="Permalink to &quot;java.lang.Class\\&lt;T&gt;&quot;">​</a></h5><h6 id="typevarialbe-gettypeparameters" tabindex="-1">TypeVarialbe[] getTypeParameters() <a class="header-anchor" href="#typevarialbe-gettypeparameters" aria-label="Permalink to &quot;TypeVarialbe[] getTypeParameters()&quot;">​</a></h6><p>如果这个类型被声明为泛型类型,则获得泛型类型变量,否则获得一个长度为0的数组。</p><h6 id="type-getgenericsuperclass" tabindex="-1">Type getGenericSuperClass() <a class="header-anchor" href="#type-getgenericsuperclass" aria-label="Permalink to &quot;Type getGenericSuperClass()&quot;">​</a></h6><p>获得这个类型所声明超类的泛型类型;如果这个类型是Object或者不是类类型(class type),则返回null。</p><h6 id="type-getgenericinterfaces" tabindex="-1">Type[] getGenericInterfaces() <a class="header-anchor" href="#type-getgenericinterfaces" aria-label="Permalink to &quot;Type[] getGenericInterfaces()&quot;">​</a></h6><p>获得这个类型所声明接口的泛型类型(按照声明的次序),否则,如果这个类型没有实现接口,则返回长度为0的数组。</p><h5 id="java-lang-reflect-method" tabindex="-1">java.lang.reflect.Method <a class="header-anchor" href="#java-lang-reflect-method" aria-label="Permalink to &quot;java.lang.reflect.Method&quot;">​</a></h5><h6 id="typevariable-gettypeparameters" tabindex="-1">TypeVariable[] getTypeParameters <a class="header-anchor" href="#typevariable-gettypeparameters" aria-label="Permalink to &quot;TypeVariable[] getTypeParameters&quot;">​</a></h6><p>如果这个方法被声明为一个泛型方法,则获得泛型类型变量,否则返回长度为0数组。</p><h6 id="type-getgenericreturntype" tabindex="-1">Type getGenericReturnType() <a class="header-anchor" href="#type-getgenericreturntype" aria-label="Permalink to &quot;Type getGenericReturnType()&quot;">​</a></h6><p>获得这个方法声明的泛型返回类型。</p><h6 id="type-getgenericparametertypes" tabindex="-1">Type[] getGenericParameterTypes() <a class="header-anchor" href="#type-getgenericparametertypes" aria-label="Permalink to &quot;Type[] getGenericParameterTypes()&quot;">​</a></h6><p>获得这个方法声明的泛型参数类型。如果这个方法没有参数,返回长度为0的数组。</p><h5 id="java-lang-reflect-typevariable" tabindex="-1">java.lang.reflect.TypeVariable <a class="header-anchor" href="#java-lang-reflect-typevariable" aria-label="Permalink to &quot;java.lang.reflect.TypeVariable&quot;">​</a></h5><h6 id="string-getname" tabindex="-1">String getName() <a class="header-anchor" href="#string-getname" aria-label="Permalink to &quot;String getName()&quot;">​</a></h6><p>获得这个类型变量的名字。</p><h6 id="type-getbounds" tabindex="-1">Type[] getBounds() <a class="header-anchor" href="#type-getbounds" aria-label="Permalink to &quot;Type[] getBounds()&quot;">​</a></h6><p>获得这个类型变量的子类限定,否则,如果该变量无限定,则返回长度为0的数组。</p><h5 id="java-lang-reflect-wildcardtype" tabindex="-1">java.lang.reflect.WildcardType <a class="header-anchor" href="#java-lang-reflect-wildcardtype" aria-label="Permalink to &quot;java.lang.reflect.WildcardType&quot;">​</a></h5><h6 id="type-getupperbounds" tabindex="-1">Type[] getUpperBounds() <a class="header-anchor" href="#type-getupperbounds" aria-label="Permalink to &quot;Type[] getUpperBounds()&quot;">​</a></h6><p>获得这个变量的子类(extends)限定,否则,如果没有子类限定,则返回长度为0的数组。</p><h6 id="type-getlowerbounds" tabindex="-1">Type[] getLowerBounds() <a class="header-anchor" href="#type-getlowerbounds" aria-label="Permalink to &quot;Type[] getLowerBounds()&quot;">​</a></h6><p>获得这个类的超类限定(super),如果没有则返回长度为0的数组。</p><h5 id="java-lang-reflect-parameterizedtype" tabindex="-1">java.lang.reflect.ParameterizedType <a class="header-anchor" href="#java-lang-reflect-parameterizedtype" aria-label="Permalink to &quot;java.lang.reflect.ParameterizedType&quot;">​</a></h5><h6 id="type-getrawtype" tabindex="-1">Type getRawType() <a class="header-anchor" href="#type-getrawtype" aria-label="Permalink to &quot;Type getRawType()&quot;">​</a></h6><p>获得这个参数话类型的原始类型。</p><h6 id="type-getactualtypearguments" tabindex="-1">Type[] getActualTypeArguments() <a class="header-anchor" href="#type-getactualtypearguments" aria-label="Permalink to &quot;Type[] getActualTypeArguments()&quot;">​</a></h6><p>获得这个参数话类型声明的类型参数。</p><h6 id="type-getownertype" tabindex="-1">Type getOwnerType() <a class="header-anchor" href="#type-getownertype" aria-label="Permalink to &quot;Type getOwnerType()&quot;">​</a></h6><p>如果是内部类型,则返回其外部类类型;如果是一个顶级类型,则返回null。</p><p>Type getOwnerType()</p><p>如果是内部类型,则返回其外部类型;如果是一个顶级类型,则返回null。</p><h5 id="java-lang-reflect-genericarraytype" tabindex="-1">java.lang.reflect.GenericArrayType <a class="header-anchor" href="#java-lang-reflect-genericarraytype" aria-label="Permalink to &quot;java.lang.reflect.GenericArrayType&quot;">​</a></h5><h6 id="type-getgenericcomponent" tabindex="-1">Type getGenericComponent() <a class="header-anchor" href="#type-getgenericcomponent" aria-label="Permalink to &quot;Type getGenericComponent()&quot;">​</a></h6><p>获得这个数组类型声明的泛型元素类型。</p>`,313),l=[h];function p(e,k,r,d,g,A){return i(),a("div",null,l)}const D=s(t,[["render",p]]);export{c as __pageData,D as default};
