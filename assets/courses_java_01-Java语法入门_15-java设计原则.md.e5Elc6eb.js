import{_ as l}from"./chunks/ArticleMetadata.TT7jIO3o.js";import{_ as i,D as c,o as r,c as d,I as h,w as _,k as o,a as p,R as u,b as m,e as v}from"./chunks/framework.FHZ5yb6k.js";import"./chunks/md5.0oexlRJv.js";const $=JSON.parse('{"title":"15-java设计原则","description":"","frontmatter":{"title":"15-java设计原则","author":"Ray","date":"2020/10/02 21:30","categories":["Java生态"],"tags":["Java","Java基础","JDK","开发环境"]},"headers":[],"relativePath":"courses/java/01-Java语法入门/15-java设计原则.md","filePath":"courses/java/01-Java语法入门/15-java设计原则.md","lastUpdated":1744847932000}'),f={name:"courses/java/01-Java语法入门/15-java设计原则.md"},b=o("h1",{id:"java面向对象设计的原则",tabindex:"-1"},[p("Java面向对象设计的原则 "),o("a",{class:"header-anchor",href:"#java面向对象设计的原则","aria-label":'Permalink to "Java面向对象设计的原则"'},"​")],-1),k=u('<h3 id="单一职责原则" tabindex="-1">单一职责原则 <a class="header-anchor" href="#单一职责原则" aria-label="Permalink to &quot;单一职责原则&quot;">​</a></h3><p>就一个类而言，应该仅有一个引起它变化的原因。 两个方法分成两个类这种方式在软件工程中太过于奢侈了，应该是一个类只负责跟自身有关的事情，有点像充血模型。</p><h3 id="开闭原则" tabindex="-1">开闭原则 <a class="header-anchor" href="#开闭原则" aria-label="Permalink to &quot;开闭原则&quot;">​</a></h3><p>对于软件中的对象(类，模块，函数等)应该对于扩展是开放的，但是对于修改是关闭的。 就是说在设计之初，就应该保留整个面向对象的扩展性(这对于将过程抽象为面向对象的功力考验极大，慢慢来吧)，后面如果有新功能应该去扩展而非修改，最常见的就是策略模式了</p><h3 id="里氏替换原则" tabindex="-1">里氏替换原则 <a class="header-anchor" href="#里氏替换原则" aria-label="Permalink to &quot;里氏替换原则&quot;">​</a></h3><p>子类可以去扩展父类的功能(抽象类)，但是不能改变父类原有的功能。</p><p>继承有缺点，因为父类的属性和方法对子类都是透明的，子类可以随意地修改父类的成员，如果子类对父类方法进行重写并且出现意外，任何使用父类型的地方都可能因为这个子类的特殊重写而出问题。</p><h3 id="依赖倒置原则" tabindex="-1">依赖倒置原则 <a class="header-anchor" href="#依赖倒置原则" aria-label="Permalink to &quot;依赖倒置原则&quot;">​</a></h3><p>高层次的模块不应该依赖于低层次的模块的实现细节的目的。 在Java中，依赖倒置原则是<strong>指模块间的依赖是通过抽象来发生的，实现类之间不发生直接依赖关系，其依赖关系是通过接口是来实现的，这就是俗称的面向接口编程</strong>。</p><h3 id="接口隔离原则" tabindex="-1">接口隔离原则 <a class="header-anchor" href="#接口隔离原则" aria-label="Permalink to &quot;接口隔离原则&quot;">​</a></h3><p>客户端不应该依赖它不需要的接口</p><p>类间的依赖关系应该建立在最小的接口上</p><h3 id="迪米特原则" tabindex="-1">迪米特原则 <a class="header-anchor" href="#迪米特原则" aria-label="Permalink to &quot;迪米特原则&quot;">​</a></h3><p>一个对象应该对其他对象保持最小的了解。</p><p>只与直接的朋友通信，耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。</p>',15);function q(a,J,P,j,x,C){const n=l,s=c("ClientOnly");return r(),d("div",null,[b,h(s,null,{default:_(()=>{var e,t;return[(((e=a.$frontmatter)==null?void 0:e.aside)??!0)&&(((t=a.$frontmatter)==null?void 0:t.showArticleMetadata)??!0)?(r(),m(n,{key:0,article:a.$frontmatter},null,8,["article"])):v("",!0)]}),_:1}),k])}const g=i(f,[["render",q]]);export{$ as __pageData,g as default};
