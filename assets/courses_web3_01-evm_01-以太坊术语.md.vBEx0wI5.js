import{_ as l}from"./chunks/ArticleMetadata.TT7jIO3o.js";import{_ as h,D as i,o,c,I as d,w as u,k as r,a as m,R as _,b as p,e as b}from"./chunks/framework.FHZ5yb6k.js";import"./chunks/md5.0oexlRJv.js";const v=JSON.parse('{"title":"以太坊术语","description":"","frontmatter":{"title":"以太坊术语","author":"Ray","date":"2025/02/22 21:30","categories":["web3生态"],"tags":["web3"],"showComment":false},"headers":[],"relativePath":"courses/web3/01-evm/01-以太坊术语.md","filePath":"courses/web3/01-evm/01-以太坊术语.md","lastUpdated":1742732500000}'),f={name:"courses/web3/01-evm/01-以太坊术语.md"},q=r("h1",{id:"以太坊术语",tabindex:"-1"},[m("以太坊术语 "),r("a",{class:"header-anchor",href:"#以太坊术语","aria-label":'Permalink to "以太坊术语"'},"​")],-1),k=_('<h2 id="账户" tabindex="-1">账户 <a class="header-anchor" href="#账户" aria-label="Permalink to &quot;账户&quot;">​</a></h2><h3 id="外部用账户-eoas" tabindex="-1">外部用账户(EOAS) <a class="header-anchor" href="#外部用账户-eoas" aria-label="Permalink to &quot;外部用账户(EOAS)&quot;">​</a></h3><p>也就是说普通用户的账户，例如我要通过合约向A钱包地址进行转账，那么这个A地址就是EOA。</p><h3 id="合约账户-ca" tabindex="-1">合约账户(CA) <a class="header-anchor" href="#合约账户-ca" aria-label="Permalink to &quot;合约账户(CA)&quot;">​</a></h3><p>我的理解是部署合约的账户，但是原话是这样的&quot;该类账户由存储在账户中的代码控制&quot;，我通过看项目也不明白它说的啥意思，而且用hardhat部署的话默认用的是生成的第一个账户。</p><h4 id="区别" tabindex="-1">区别 <a class="header-anchor" href="#区别" aria-label="Permalink to &quot;区别&quot;">​</a></h4><p><strong>只有外部用户账户可以发起交易（主动行为），而合约账户只能被动地响应操作，并且所有的手续费（Gas）必须由外部账户支付</strong></p><h3 id="账户状态" tabindex="-1">账户状态 <a class="header-anchor" href="#账户状态" aria-label="Permalink to &quot;账户状态&quot;">​</a></h3><h4 id="nonce" tabindex="-1">nonce <a class="header-anchor" href="#nonce" aria-label="Permalink to &quot;nonce&quot;">​</a></h4><p>如果账户是一个外部用户账户，nonce代表从此账户地址发送的交易序号。如果账户是一个合约账户，nonce代表此账户创建的合约序号。说实话，看得不是很懂。</p><p>以太坊中有两种nonce ， 一种是账号nonce——表示一个账号的交易数量；一种是工作量证明nonce——一个用于计算满足工作量证明的随机数。</p><h4 id="balance" tabindex="-1">balance <a class="header-anchor" href="#balance" aria-label="Permalink to &quot;balance&quot;">​</a></h4><p>该地址拥有的以太币余额数量</p><h4 id="storageroot" tabindex="-1">storageRoot <a class="header-anchor" href="#storageroot" aria-label="Permalink to &quot;storageRoot&quot;">​</a></h4><p>Merkle Patricia树的根节点哈希值。Merkle树会将此账户存储内容的哈希值进行编码，默认是空值。</p><h4 id="codehash" tabindex="-1">codeHash <a class="header-anchor" href="#codehash" aria-label="Permalink to &quot;codeHash&quot;">​</a></h4><p>此账户代码的哈希值。</p><h2 id="以太币" tabindex="-1">以太币 <a class="header-anchor" href="#以太币" aria-label="Permalink to &quot;以太币&quot;">​</a></h2><p>以太坊的原生币，最小单位1wei，标准单位是1eth,称为1以太。</p><h2 id="以太坊虚拟机-evm" tabindex="-1">以太坊虚拟机(EVM) <a class="header-anchor" href="#以太坊虚拟机-evm" aria-label="Permalink to &quot;以太坊虚拟机(EVM)&quot;">​</a></h2><p>EVM是一种虚拟计算机，看到这个和Java生态中的JVM有点像，我目前还不知道二者有何联系。智能合约就是在EVM上运行的，它会将智能合约代码的字节码(熟悉的味儿来了)加载到内存中，然后按照预定的规则执行该字节码。gas的概念就是由EVM引入进来的，为了防止恶意代码无限循环或耗尽计算资源。</p><h2 id="gas机制" tabindex="-1">Gas机制 <a class="header-anchor" href="#gas机制" aria-label="Permalink to &quot;Gas机制&quot;">​</a></h2><h2 id="以太坊交易" tabindex="-1">以太坊交易 <a class="header-anchor" href="#以太坊交易" aria-label="Permalink to &quot;以太坊交易&quot;">​</a></h2>',23);function P(a,x,g,V,A,w){const n=l,s=i("ClientOnly");return o(),c("div",null,[q,d(s,null,{default:u(()=>{var e,t;return[(((e=a.$frontmatter)==null?void 0:e.aside)??!0)&&(((t=a.$frontmatter)==null?void 0:t.showArticleMetadata)??!0)?(o(),p(n,{key:0,article:a.$frontmatter},null,8,["article"])):b("",!0)]}),_:1}),k])}const N=h(f,[["render",P]]);export{v as __pageData,N as default};
