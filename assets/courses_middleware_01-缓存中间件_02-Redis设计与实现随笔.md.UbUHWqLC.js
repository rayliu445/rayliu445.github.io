import{_ as s,o as i,c as a,R as n}from"./chunks/framework.FVQzxbLi.js";const A=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"courses/middleware/01-缓存中间件/02-Redis设计与实现随笔.md","filePath":"courses/middleware/01-缓存中间件/02-Redis设计与实现随笔.md","lastUpdated":1743871467000}'),h={name:"courses/middleware/01-缓存中间件/02-Redis设计与实现随笔.md"},l=n(`<h2 id="数据结构和对象" tabindex="-1">数据结构和对象 <a class="header-anchor" href="#数据结构和对象" aria-label="Permalink to &quot;数据结构和对象&quot;">​</a></h2><h3 id="概述" tabindex="-1">概述 <a class="header-anchor" href="#概述" aria-label="Permalink to &quot;概述&quot;">​</a></h3><p>这篇博客作为前一篇基础使用之后的进阶篇</p><h3 id="对象" tabindex="-1">对象 <a class="header-anchor" href="#对象" aria-label="Permalink to &quot;对象&quot;">​</a></h3><p>书上是按照先介绍底层的数据结构，然后再介绍5种基本的存储类型，但是呢我觉得先看一大堆数据结构可能会失去兴趣，所以我将Redis中对象的设计放在前面，通过对象的设计去探究底层的数据结构对我来说更加容易一些</p><h4 id="_5种基本类型" tabindex="-1">5种基本类型 <a class="header-anchor" href="#_5种基本类型" aria-label="Permalink to &quot;5种基本类型&quot;">​</a></h4><p>就是入门篇里提到的5种类型对象 String、List、Set、Zset、Hash <strong>注:由于Redis里面都是键对象和值对象,所以这一章的角度都是从这两个对象出发</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span>EVAL &quot;for i=1, 128 do redis.call(&#39;ZADD&#39;, KEYS[1], i, i) end&quot; 1 numbers</span></span></code></pre></div><p>上面这段代码是往一个zset里面插入128个元素,从1开始 在开始内容之前需要先看一个数据结构</p><div class="language-C vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">C</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> redisObject{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    //类型</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    unsigned</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> type:</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    //编码</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    unsigned</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> encoding:</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    //指向底层实现数据结构的设计</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">ptr;  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    //对象的空转时长</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    unsigned</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> lru:</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">22</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    //引用计数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> refcount;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><h5 id="不同类型的编码方式" tabindex="-1">不同类型的编码方式 <a class="header-anchor" href="#不同类型的编码方式" aria-label="Permalink to &quot;不同类型的编码方式&quot;">​</a></h5><p>虽然Redis有5种基本数据类型,但是每种数据类型还是的底层还是有至少两种以上的编码方式(这里说的编码方式和底层用的数据结构不是一个概念) 这里就不得不提一下多态了,真的是随处可见,比如说所有的类型都能够使用命令DEL 有些命令是数据类型独有的,例如RPUSH、ZADD,这些命令在执行时,不同底层编码方式也都会执行这些指令。</p><h5 id="类型检查" tabindex="-1">类型检查 <a class="header-anchor" href="#类型检查" aria-label="Permalink to &quot;类型检查&quot;">​</a></h5><p>服务器在执行某些命令前,会先检查给定键的类型能够执行指定的命令,其实就是检查值对象的类型</p><h5 id="内存回收机制" tabindex="-1">内存回收机制 <a class="header-anchor" href="#内存回收机制" aria-label="Permalink to &quot;内存回收机制&quot;">​</a></h5><p>对象上有个字段refcount,代表当前对象被引用次数,如果为0,则会从内存中删除掉</p><h5 id="内存共享" tabindex="-1">内存共享 <a class="header-anchor" href="#内存共享" aria-label="Permalink to &quot;内存共享&quot;">​</a></h5><p>0-9999整数值会预先存好,就像Java的字符串常量池一样</p><h5 id="空转时间" tabindex="-1">空转时间 <a class="header-anchor" href="#空转时间" aria-label="Permalink to &quot;空转时间&quot;">​</a></h5><p>越近访问的值空转时间会越少</p><h3 id="字符串" tabindex="-1">字符串 <a class="header-anchor" href="#字符串" aria-label="Permalink to &quot;字符串&quot;">​</a></h3><h4 id="sdc-simple-dynamic-string-简单动态字符串-数据结构" tabindex="-1">SDC(Simple Dynamic String,简单动态字符串)数据结构 <a class="header-anchor" href="#sdc-simple-dynamic-string-简单动态字符串-数据结构" aria-label="Permalink to &quot;SDC(Simple Dynamic String,简单动态字符串)数据结构&quot;">​</a></h4><p>每个sds.h/sdshdr结构表示一个SDS值</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> sdshdr{  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    //记录buf数组中已使用字节的数量</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    //等于SDS所保存字符串的长度</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> len;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    //记录buf数组中未使用字节的数量</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> free;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    //字节数组，用于保存字符串</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    char</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> buf</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">[]</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">; </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><h5 id="优势" tabindex="-1">优势 <a class="header-anchor" href="#优势" aria-label="Permalink to &quot;优势&quot;">​</a></h5><ol><li>常数复杂度获取字符串长度 数据结构中有len属性用于保存字符串的长度</li><li>杜绝缓冲区溢出 在字符串进行扩展前,会先检查一下buff的长度是否足够,如果不够的话就会进行扩展,然后再执行添加字符的操作</li><li>减少内存分配次数 <strong>SDS通过两种策略来实现</strong><ol><li><strong>空间预分配</strong> 如果对SDS进行修改之后,len属性小于1MB,那么程序分配和len同样大小的未使用空间,即len和free属性值相同;如果大于1MB,那么将分配1MB未使用空间</li><li><strong>惰性空间释放</strong> 当SDS的API需要缩短保存的字符串时,<strong>内存重分配</strong>不会立即释放未使用的空间,而是将其作为free的数量</li></ol></li><li>二进制安全 首先需要了解C,C的字符串必须符合某种编码,例如如果一开始读入空格将被识别为结尾SDS以二进制形式存储,文本存进去是什么内容,拿出来就还是什么内容</li><li>兼容部分C字符串函数 SDS遵循C字符串以空字符结尾,这样就能重用/&lt;string.h&gt;的stracasecmp函数</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span>strcasecpm(sds-&gt;buff,&quot;hello world!&quot;)</span></span></code></pre></div><h3 id="链表" tabindex="-1">链表 <a class="header-anchor" href="#链表" aria-label="Permalink to &quot;链表&quot;">​</a></h3><h4 id="数据结构" tabindex="-1">数据结构 <a class="header-anchor" href="#数据结构" aria-label="Permalink to &quot;数据结构&quot;">​</a></h4><p>双向链表</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> list{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    //表头节点  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    listNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> head;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    //表尾节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    listNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> tail;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    //链表所包含的节点</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> long</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> len;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    //节点值复制函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">dup)(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">ptr);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    //节点值释放函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    void</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">free)(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">ptr);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    //节点值对比函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">keyCompare)(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">ptr1, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">ptr2);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}list</span></span></code></pre></div><p>复习一下结点的数据结构(梦回408王道数据结构)</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> listNode{  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    //前置节点</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    struct</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> ListNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> prev;  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    //后置节点</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    struct</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> ListNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> next;  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    //节点的值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> value;  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">} </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">listNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> tail;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> long</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> len;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">//节点复制函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">dup)(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">ptr)</span></span></code></pre></div><h4 id="特性" tabindex="-1">特性 <a class="header-anchor" href="#特性" aria-label="Permalink to &quot;特性&quot;">​</a></h4><p>双端、无环、带表头和表尾指针、带链表长度计数器和多态(个人理解和Java的多态好像不太一样) 关于多态这里解释一下,以复制函数为例,使用的void*指针来保存节点值,所以可以保存各种不同类型的值</p><h4 id="用途" tabindex="-1">用途 <a class="header-anchor" href="#用途" aria-label="Permalink to &quot;用途&quot;">​</a></h4><ol><li>列表键、发布与订阅、慢查询、监视器等 列表键暂时不知 发布与订阅容易消息丢失,适用于要求不高的场景,可以从确保消息不丢失的问题延伸 慢查询暂时不知 监视器暂时不知</li></ol><h3 id="字典" tabindex="-1">字典 <a class="header-anchor" href="#字典" aria-label="Permalink to &quot;字典&quot;">​</a></h3><h4 id="哈希表节点与哈希表数据结构" tabindex="-1">哈希表节点与哈希表数据结构 <a class="header-anchor" href="#哈希表节点与哈希表数据结构" aria-label="Permalink to &quot;哈希表节点与哈希表数据结构&quot;">​</a></h4><h5 id="哈希表结构" tabindex="-1">哈希表结构 <a class="header-anchor" href="#哈希表结构" aria-label="Permalink to &quot;哈希表结构&quot;">​</a></h5><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">typdef </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> dictht{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    //哈希表数组</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    dictEntry </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">**</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> table;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    //哈希表大小</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> long</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> size;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    //哈希表掩码，用于计算索引值</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    //总是等于size-1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> long</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> sizemask;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    //哈希表元素数量</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> long</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> used;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}dictht</span></span></code></pre></div><h5 id="哈希表节点结构" tabindex="-1">哈希表节点结构 <a class="header-anchor" href="#哈希表节点结构" aria-label="Permalink to &quot;哈希表节点结构&quot;">​</a></h5><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">typef </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> dictEntry{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    //键</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> key;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    //值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    union</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> value;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        uint64_tu64;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        int64_ts64;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }v;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    //指向下一个节点</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    struct</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> dictEntry </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> next;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}dictEntry</span></span></code></pre></div><h5 id="字典结构" tabindex="-1">字典结构 <a class="header-anchor" href="#字典结构" aria-label="Permalink to &quot;字典结构&quot;">​</a></h5><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> dict{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    //类型特定函数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    dictType </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> type;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    //私有数据</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> privData;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    //哈希表</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    dictht </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">ht</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">];</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    //rehash索引</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    //当rehash进行中,rehashIndex的值会不断增加,直到为-1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> trehashidx; </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}dict;</span></span></code></pre></div><p>type属性是一个指向dictType结构的指针，每个dictType结构<strong>保存了一簇用于操作特定类型键值对的函数</strong>，Redis会为用途不同的字典设置不同的类型特定函数。</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> dictType{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    //计算哈希值的函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    unsigned</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">int|long</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">)(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">hashFunction)(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">key);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    //复制键的函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">keyDup)(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">privdata, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">key);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    //复制值的函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">valDup)(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">privdata, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">obj);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    //比较键的函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">keyCompare)(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">privdata, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">key1, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">key2);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    //释放键的函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    void</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">keyDestructor)(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">privdata, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">key);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    //释放值的函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    void</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">valDestructor)(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">privdata, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">obj);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p><img src="https://raw.githubusercontent.com/aryangzhu/blogImage/master/%E6%88%AA%E5%B1%8F2023-04-04%20%E4%B8%8B%E5%8D%883.34.26.png" alt=""> 从上面的图里可以看到,字典中有哈希表结构,而哈希表中有key-value键值节点</p><h4 id="哈希算法" tabindex="-1">哈希算法 <a class="header-anchor" href="#哈希算法" aria-label="Permalink to &quot;哈希算法&quot;">​</a></h4><p>通过键来计算出哈希值和索引值(通过哈希值和哈希掩码计算出来),将包含新键值对的哈希表节点放在置顶索引上面</p><h4 id="解决键冲突-哈希冲突" tabindex="-1">解决键冲突(哈希冲突) <a class="header-anchor" href="#解决键冲突-哈希冲突" aria-label="Permalink to &quot;解决键冲突(哈希冲突)&quot;">​</a></h4><p>链表法</p><h4 id="rehash-重新散列" tabindex="-1">rehash(重新散列) <a class="header-anchor" href="#rehash-重新散列" aria-label="Permalink to &quot;rehash(重新散列)&quot;">​</a></h4><p>说人话就是为了在字典里面的数据增加或者减少的时候将<strong>哈希表的长度控制在一定范围内,避免不够用或者过于浪费</strong>当哈希表增加或者缩减到一定程度时就会触发rehash操作</p><ol><li>如果是增加,那么ht[1]的大小等于ht[0].used*2的2^n^如果是减少,那么ht[1]的大小等于ht[0].used的2^n^</li><li>将ht[0]的所有键值都放到ht[1]中,这个过程会重新计算hash值和索引值</li><li>释放ht[0],然后将ht[1]设置为ht[0],并且在ht[1]新创建一个空白哈希表,为下一次的rehash做准备</li></ol><h4 id="渐进式rehash" tabindex="-1">渐进式rehash <a class="header-anchor" href="#渐进式rehash" aria-label="Permalink to &quot;渐进式rehash&quot;">​</a></h4><p>先定义一个rehashindex变量,初始值为0,在执行新增、删除、查询时都会将对应ht[0]的redisindex索引处的key-value重新散列到ht[1],并且在渐进式rehash期间,新增的结点不会进入到ht[0]中,就保证了ht[0]最终会成为空表(意义在哪???)</p><h3 id="跳跃表" tabindex="-1">跳跃表 <a class="header-anchor" href="#跳跃表" aria-label="Permalink to &quot;跳跃表&quot;">​</a></h3><p>几个重要的概念</p><ol><li>前进指针 每个跳跃表结点都有指向下一个结点的指针</li><li>层 每个跳跃表结点都会有很多层,至于具体是干什么的现在还不太清楚</li><li>后退指针 最后一个跳跃表结点指向前一个结点</li><li>跨度 就是从头结点开始到目标结点经历的路径,有点想图的权</li><li>分值和成员 分值是一个double类型的浮点数,跳跃表中的所有的结点的分值按照从小大来排序 <img src="https://raw.githubusercontent.com/aryangzhu/blogImage/master/%E6%88%AA%E5%B1%8F2023-04-05%20%E4%B8%8A%E5%8D%8810.16.54.png" alt=""> 对象是一个指针,它指向一个字符串对象,而字符串对象中则保存一个SDS值 不太清楚一个跳跃表结点是不是只能存放一个对象,但是我猜测是这样的</li></ol><h4 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h4><ol><li>Redis的跳跃表实现是由zkiplist和zkiplistNode两个结构组成,其中zkiplist用于保存跳跃表信息(比如表头节点、表尾节点、长度),而zskiplistNode则用于跳跃表节点</li><li>多个跳跃表节点的分值可以相同,但是对象必须唯一</li></ol><h3 id="整数集合" tabindex="-1">整数集合 <a class="header-anchor" href="#整数集合" aria-label="Permalink to &quot;整数集合&quot;">​</a></h3><p>整数集合是集合键的底层实现之一,当一个集合只包含整数值元素,并且这个集合的元素数量不多时,Redis sadd numbers 1 3 5 7 9 上面的命令用的是sadd,说明用的集合set的基本类型(Redis对外提供的)</p><h4 id="升级" tabindex="-1">升级 <a class="header-anchor" href="#升级" aria-label="Permalink to &quot;升级&quot;">​</a></h4><p>先来看数据结构</p><div class="language-C vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">C</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">typedef</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> strunct intset{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">    unit32_t</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> encoding;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>上面的encoding属性决定当前数组的元素是用什么方式编码,如果当前是inset_enc_int16,此时再添加进一个64位编码的元素那么就会执行升级操作 整数集合只支持<strong>升级</strong>而不支持降级</p><h3 id="压缩列表" tabindex="-1">压缩列表 <a class="header-anchor" href="#压缩列表" aria-label="Permalink to &quot;压缩列表&quot;">​</a></h3><p>压缩列表ziplist是列表键(List???)和哈希键(Hash???)的底层实现之一。当一个列表键只包含少量列表项,并且每个列表项要么是小整数值,要么是长度比较短的字符串,那么Redis就会使用压缩列表来做列表键的底层实现 在3.2和5之后引入了quicklist和listpack,所以废弃了</p><h2 id="单机数据库的实现" tabindex="-1">单机数据库的实现 <a class="header-anchor" href="#单机数据库的实现" aria-label="Permalink to &quot;单机数据库的实现&quot;">​</a></h2><h3 id="选择数据库" tabindex="-1">选择数据库 <a class="header-anchor" href="#选择数据库" aria-label="Permalink to &quot;选择数据库&quot;">​</a></h3><p>select 0(index) 客户端程序中有个数据结构,其中有个属性保存了当前客户端使用的数据库</p><h3 id="数据库键空间" tabindex="-1">数据库键空间 <a class="header-anchor" href="#数据库键空间" aria-label="Permalink to &quot;数据库键空间&quot;">​</a></h3><p>首先来看redis-server的结构</p><p><img src="https://raw.githubusercontent.com/rayliu445/blogImage/master/blogImage/202504050717064.png" alt=""></p><p>数据库键空间是这一章的重点 <img src="https://raw.githubusercontent.com/aryangzhu/blogImage/master/%E6%88%AA%E5%B1%8F2023-04-07%20%E4%B8%8B%E5%8D%882.26.03.png" alt=""></p><p>从上面可以看出dict</p><h5 id="关于键值变化时的操作过程" tabindex="-1">关于键值变化时的操作过程 <a class="header-anchor" href="#关于键值变化时的操作过程" aria-label="Permalink to &quot;关于键值变化时的操作过程&quot;">​</a></h5><ol><li>新增键</li><li>删除键</li><li>更新键</li><li>读写键的维护操作 服务器中键有命中和不命中次数属性,是一个统计指标 键有ideltime,用来指示键的闲置时间 键有过期时长,不知道和这个闲置时间的属性有什么关系 键有个属性代表是否被修改,书上说的是键是不是为dirty(脏键),每次修改这个值都会被加1,如果客户端使用WATCH命令对其进行了监听,那么客户端程序在执行事务程序时就会注意到。</li></ol><h4 id="设置生存或者过期时间" tabindex="-1">设置生存或者过期时间 <a class="header-anchor" href="#设置生存或者过期时间" aria-label="Permalink to &quot;设置生存或者过期时间&quot;">​</a></h4><h3 id="rdb持久化" tabindex="-1">RDB持久化 <a class="header-anchor" href="#rdb持久化" aria-label="Permalink to &quot;RDB持久化&quot;">​</a></h3><h4 id="save和bgsave" tabindex="-1">SAVE和BGSAVE <a class="header-anchor" href="#save和bgsave" aria-label="Permalink to &quot;SAVE和BGSAVE&quot;">​</a></h4><h4 id="mac下使用homebrew安装的redis的rdb文件位置" tabindex="-1">Mac下使用Homebrew安装的Redis的RDB文件位置 <a class="header-anchor" href="#mac下使用homebrew安装的redis的rdb文件位置" aria-label="Permalink to &quot;Mac下使用Homebrew安装的Redis的RDB文件位置&quot;">​</a></h4><ol><li>首先还是得找到redis.conf的位置 使用brew info redis命令可以查看到 /opt/homebrew/etc/redis.conf</li><li>在redis.conf找到dbfilename和dir属性的值来确定文件名称和路径 db.dump和/opt/homebrew/var/db/redis</li></ol><h3 id="aof持久化" tabindex="-1">AOF持久化 <a class="header-anchor" href="#aof持久化" aria-label="Permalink to &quot;AOF持久化&quot;">​</a></h3><h4 id="aof缓冲区" tabindex="-1">AOF缓冲区 <a class="header-anchor" href="#aof缓冲区" aria-label="Permalink to &quot;AOF缓冲区&quot;">​</a></h4><h4 id="重写" tabindex="-1">重写 <a class="header-anchor" href="#重写" aria-label="Permalink to &quot;重写&quot;">​</a></h4><h5 id="aof重写缓冲区" tabindex="-1">AOF重写缓冲区 <a class="header-anchor" href="#aof重写缓冲区" aria-label="Permalink to &quot;AOF重写缓冲区&quot;">​</a></h5><h3 id="事件" tabindex="-1">事件 <a class="header-anchor" href="#事件" aria-label="Permalink to &quot;事件&quot;">​</a></h3><p>首先来复习一下多路复用,没办法用的多有什么辙 几个关键的记忆点,bind()函数和accept()函数,socket 客户端connect() 已连接队列 多进程模型 多线程模型 IO多路复用模型select()和poll() IO多路复用模型epoll() 事件机制,回调函数</p><h4 id="redis中的io多路复用" tabindex="-1">Redis中的IO多路复用 <a class="header-anchor" href="#redis中的io多路复用" aria-label="Permalink to &quot;Redis中的IO多路复用&quot;">​</a></h4><h3 id="客户端" tabindex="-1">客户端 <a class="header-anchor" href="#客户端" aria-label="Permalink to &quot;客户端&quot;">​</a></h3><p>主要内容是服务器内部保存的redis-client结构,对其中的的属性进行讲解</p><h3 id="服务端" tabindex="-1">服务端 <a class="header-anchor" href="#服务端" aria-label="Permalink to &quot;服务端&quot;">​</a></h3><h2 id="多机数据库的实现" tabindex="-1">多机数据库的实现 <a class="header-anchor" href="#多机数据库的实现" aria-label="Permalink to &quot;多机数据库的实现&quot;">​</a></h2><h3 id="复制" tabindex="-1">复制 <a class="header-anchor" href="#复制" aria-label="Permalink to &quot;复制&quot;">​</a></h3><h3 id="sential" tabindex="-1">Sential <a class="header-anchor" href="#sential" aria-label="Permalink to &quot;Sential&quot;">​</a></h3><h3 id="集群" tabindex="-1">集群 <a class="header-anchor" href="#集群" aria-label="Permalink to &quot;集群&quot;">​</a></h3><h2 id="独立功能的实现" tabindex="-1">独立功能的实现 <a class="header-anchor" href="#独立功能的实现" aria-label="Permalink to &quot;独立功能的实现&quot;">​</a></h2><h2 id="一点碎碎念" tabindex="-1">一点碎碎念 <a class="header-anchor" href="#一点碎碎念" aria-label="Permalink to &quot;一点碎碎念&quot;">​</a></h2><p>最近因为面试，所以又拿出了《Redis设计与实现》这本书出来复习，其实23年的时候就已经刷过一遍这本书了，但是没有做笔记，今年发现做笔记和不做笔记差别还是挺大的。这两天也不想去复盘之前的面试(畏难心理还是已经皮实了，不想再继续下去了)，索性就写写笔记，当做一种娱乐了。</p>`,102),t=[l];function e(p,k,r,d,o,c){return i(),a("div",null,t)}const y=s(h,[["render",e]]);export{A as __pageData,y as default};
