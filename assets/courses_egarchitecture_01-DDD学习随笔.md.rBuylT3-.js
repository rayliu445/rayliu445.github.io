import{_ as n}from"./chunks/ArticleMetadata.Sb1DYAHo.js";import{_ as l,D as s,o as r,c,I as h,w as D,k as o,a as u,R as m,b as _,e as p}from"./chunks/framework.FVQzxbLi.js";import"./chunks/md5.RtphNWHi.js";const V=JSON.parse('{"title":"DDD学习随笔","description":"","frontmatter":{"title":"DDD学习随笔","author":"Ray","date":"2022/10/22 21:25","categories":["工程架构"],"tags":["DDD"]},"headers":[],"relativePath":"courses/egarchitecture/01-DDD学习随笔.md","filePath":"courses/egarchitecture/01-DDD学习随笔.md","lastUpdated":1743987058000}'),b={name:"courses/egarchitecture/01-DDD学习随笔.md"},f=o("h1",{id:"ddd学习随笔",tabindex:"-1"},[u("DDD学习随笔 "),o("a",{class:"header-anchor",href:"#ddd学习随笔","aria-label":'Permalink to "DDD学习随笔"'},"​")],-1),g=m('<h2 id="从mvc到ddd" tabindex="-1">从MVC到DDD <a class="header-anchor" href="#从mvc到ddd" aria-label="Permalink to &quot;从MVC到DDD&quot;">​</a></h2><p>首先，MVC是一种优秀的设计模式，但是随着时代的发展一些弊病也逐渐暴露出来。例如在微服务的场景下如果将服务拆分过细的话那么每次开发功能都需要上线一大批的微服务，这样不仅发版风险高，并且和其他团队进行配合的时候需要沟通的成本也高。还有就是随着业务的迭代，各个服务里面的对象也会膨胀且调用关系复杂。</p><h3 id="ddd是什么" tabindex="-1">DDD是什么 <a class="header-anchor" href="#ddd是什么" aria-label="Permalink to &quot;DDD是什么&quot;">​</a></h3><h2 id="ddd的概念" tabindex="-1">DDD的概念 <a class="header-anchor" href="#ddd的概念" aria-label="Permalink to &quot;DDD的概念&quot;">​</a></h2><h3 id="领域模型与充血模型" tabindex="-1">领域模型与充血模型 <a class="header-anchor" href="#领域模型与充血模型" aria-label="Permalink to &quot;领域模型与充血模型&quot;">​</a></h3><p><img src="https://raw.githubusercontent.com/rayliu445/blogImage/master/blogImage/ddd%E6%A8%A1%E5%BC%8F%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B20250402.png" alt="img"></p><p>上面这张图我们可以看到一个充血对象将自己的职责纳入到其中，例如，放在过去，AB服务中要是都使用同一个Redis的key，那么就需要在各自的服务中进行RedisKey的拼接。现在，我们将提供Key的功能划分给key所对应的充血模型，AB服务只需要关注自己业务即可。</p><h4 id="充血模型" tabindex="-1">充血模型 <a class="header-anchor" href="#充血模型" aria-label="Permalink to &quot;充血模型&quot;">​</a></h4><p>指将对象的<strong>属性信息与行为逻辑聚合到一个类</strong>中，常用的手段如：在对象内提供属于当前对象的信息校验、拼装缓存key、不含服务接口调用的逻辑处理等。</p><h4 id="领域模型" tabindex="-1">领域模型 <a class="header-anchor" href="#领域模型" aria-label="Permalink to &quot;领域模型&quot;">​</a></h4><p>指特定业务领域内，业务规则、策略以及业务流程的抽象和封装。小傅哥的图很明显地能展示出来</p><p><img src="https://raw.githubusercontent.com/rayliu445/blogImage/master/blogImage/%E5%A4%A7%E8%90%A5%E9%94%80DDD%E6%A6%82%E5%BF%B5%E7%90%86%E8%AE%BA%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B20250407.png" alt=""></p><h3 id="实体、聚合和值对象" tabindex="-1">实体、聚合和值对象 <a class="header-anchor" href="#实体、聚合和值对象" aria-label="Permalink to &quot;实体、聚合和值对象&quot;">​</a></h3><h4 id="实体" tabindex="-1">实体 <a class="header-anchor" href="#实体" aria-label="Permalink to &quot;实体&quot;">​</a></h4><h4 id="值对象" tabindex="-1">值对象 <a class="header-anchor" href="#值对象" aria-label="Permalink to &quot;值对象&quot;">​</a></h4><h2 id="工程模型" tabindex="-1">工程模型 <a class="header-anchor" href="#工程模型" aria-label="Permalink to &quot;工程模型&quot;">​</a></h2>',16);function E(a,A,q,k,P,x){const d=n,i=s("ClientOnly");return r(),c("div",null,[f,h(i,null,{default:D(()=>{var e,t;return[(((e=a.$frontmatter)==null?void 0:e.aside)??!0)&&(((t=a.$frontmatter)==null?void 0:t.showArticleMetadata)??!0)?(r(),_(d,{key:0,article:a.$frontmatter},null,8,["article"])):p("",!0)]}),_:1}),g])}const I=l(b,[["render",E]]);export{V as __pageData,I as default};
