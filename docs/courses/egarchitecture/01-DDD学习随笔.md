---
title: DDD学习随笔
author: Ray
date: 2022/10/22 21:25
categories:
 - 工程架构
tags:
 - DDD
---
# DDD学习随笔

## 从MVC到DDD

首先，MVC是一种优秀的设计模式，但是随着时代的发展一些弊病也逐渐暴露出来。例如在微服务的场景下如果将服务拆分过细的话那么每次开发功能都需要上线一大批的微服务，这样不仅发版风险高，并且和其他团队进行配合的时候需要沟通的成本也高。还有就是随着业务的迭代，各个服务里面的对象也会膨胀且调用关系复杂。

### DDD是什么

## DDD的概念

### 领域模型与充血模型

![img](https://raw.githubusercontent.com/rayliu445/blogImage/master/blogImage/ddd%E6%A8%A1%E5%BC%8F%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B20250402.png)

上面这张图我们可以看到一个充血对象将自己的职责纳入到其中，例如，放在过去，AB服务中要是都使用同一个Redis的key，那么就需要在各自的服务中进行RedisKey的拼接。现在，我们将提供Key的功能划分给key所对应的充血模型，AB服务只需要关注自己业务即可。

#### 充血模型

指将对象的**属性信息与行为逻辑聚合到一个类**中，常用的手段如：在对象内提供属于当前对象的信息校验、拼装缓存key、不含服务接口调用的逻辑处理等。

#### 领域模型

指特定业务领域内，业务规则、策略以及业务流程的抽象和封装。小傅哥的图很明显地能展示出来

![](https://raw.githubusercontent.com/rayliu445/blogImage/master/blogImage/%E5%A4%A7%E8%90%A5%E9%94%80DDD%E6%A6%82%E5%BF%B5%E7%90%86%E8%AE%BA%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B20250407.png)

### 实体、聚合和值对象

#### 实体

实体=唯一标识+状态属性+行为动作(功能)，是DDD中的一个基本建块，它代表了具有唯一标识的领域对象。实体不仅包含数据(状态属性)，还包含了相关的行为(功能)，并且在它的标识在整个生命周期中保持不变。

#### 值对象

这个对象在领域服务方法的生命周期过程内是不可变对象，也没有唯一标识。

值对象是由一组属性组成的的，他们共同描述了一个领域概念

#### 聚合

如果我们有对数据库的操作需要用到多个实体的时候，可以创建聚合对象，一个聚合对象，代表着一个数据库事务，具有事务的一致性。

### 仓储

将领域数据交互实现隔离开来，对于领域来说不关心怎么去做数据的交互，而是将重点放在领域内的业务流程上

### 适配器和触发器

为什么把这两个放在一起，因为有一种六边形模型中适配器就是来处理领域输入，触发器来处理领域输出。但是适配器更加特殊一点，它更像是一层中间层(设计模式中在工程上的应用)

### 领域编排

你要实现完整的业务流程就需要使用到多个领域，那么就要串联各个领域模块提供一条链路，遵循的原则就是**领域内事务一致性，领域外最终一致性**。

## 建模方法

这里直接结合大营销平台去上手更加容易一点

## 工程模型

### 工程结构设计

![](https://raw.githubusercontent.com/rayliu445/blogImage/master/blogImage/%E5%A4%A7%E8%90%A5%E9%94%80%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1%E5%9B%BE20250407.png)

#### 1.整洁架构

阿里的cola偏整洁架构，会将所有的外部依赖使用和工程内要对外的，统一定义到适配器层。

![](https://raw.githubusercontent.com/rayliu445/blogImage/master/blogImage/%E5%A4%A7%E8%90%A5%E9%94%80%E6%95%B4%E6%B4%81%E6%9E%B6%E6%9E%8420250407.png)

#### 2.六边形架构-工程架构

![](https://raw.githubusercontent.com/rayliu445/blogImage/master/blogImage/%E5%A4%A7%E8%90%A5%E9%94%80%E5%B7%A5%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%85%AD%E8%BE%B9%E5%BD%A2%E7%BB%93%E6%9E%8420250407.png)

### 领域模型设计

#### 分包方式

![](https://raw.githubusercontent.com/rayliu445/blogImage/master/blogImage/%E5%A4%A7%E8%90%A5%E9%94%80%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A120250407.png)

区别就是第一种将所有的都放在了一起，第二种先按领域进行分包，这种适合领域比较多的情况。

#### 领域模型

一个领域模型=一个充血结构

![](https://raw.githubusercontent.com/rayliu445/blogImage/master/blogImage/%E5%A4%A7%E8%90%A5%E9%94%80%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A120250407.png)

1. model模型对象

   * aggreate:聚合对象->实体对象、值对象的协同组织，就是聚合对象
   * entity:实体对象->大多数情况下，实体对象Entity与数据库持久化对象(PO)是1V1的关系，但是也有为了封装一些属性信息，会出现1vn的关系
   * valobj:值对象->通过对象属性值来识别对象By《实现领域驱动设计》
2. repository仓储服务
   依赖倒置，难道是基础层引用领域层？？？，不知道为什么要叫做依赖倒置
3. service服务设计
   如果将聚合对象超过1个对象外的逻辑封装在其中，那么代码后期越来越难维护。**如果你的设计模式应用不佳，那么无论是领域驱动设计、测试驱动设计还是换了3层和4层架构，工程质量依然会非常差。**
4. 对象解释

   * DTO:数据传输对象

### 分层调用链路
