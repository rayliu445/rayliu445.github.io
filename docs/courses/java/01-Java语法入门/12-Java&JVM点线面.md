---
title: 12-Java&JVM点线面
author: Ray
date: 2020/10/02 21:30
categories:
 - Java生态
tags:
 - Java
 - Java基础
 - JDK
 - 开发环境
---
## Java再认知

说在开头:主要是从逻辑结构出发而非物理结构,抽象思维也是Java

### 面向过程&面向对象

面向过程:注重的是数据的流向
面向对象:关注的是对象之间的交互

### Java、C++和C的区别

Java和C++都是面向对象
C++和C直接操作计算机系统内存,也就是说资源的释放得我们自己手动来处理。
当然，Java也有手动处理的,但是比C++方便,可以理解为内存之上有个JVM。

#### JVM

按照黄的讲解，JVM应该是内存一级的，所以才有一次编写,到处运行的特性。

### JVM、JDK、JRE

JVM java虚拟机
JDK java开发工具
JRE java运行环境

#### java命令与javac命令

## 字节码与类的创建过程

### 从JVM角度出发

![](https://raw.githubusercontent.com/aryangzhu/blogImage/master/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E2%80%98.jpeg)
从图上可以看出,class文件中类型信息(class还是interface,类名)会加载到方法区(逻辑,一个概念),随后会**创建main线程并将其压入线程栈**中(每个线程都有自己的线程栈,也就是说将Hello hello放在线程栈中)。
如果遇到new XXX那么就会创建一个变量，并在堆内存中开辟空间。**对象声明就是对象变量指向对内存中地址**

#### 对象在堆内存中的创建过程

1. 加载实例信息在开辟的内存中
2. 执行构造方法,即\<init>方法

##### 头部信息

1. 对齐填充
2. 持有**指向方法区的指针**
3. 描述信息(持有当前对象锁的线程的id和持有对象锁的线程的个数,在gc中存活的生命周期数,偏向锁的标志)

#### 类的加载过程(将.class文件加载到方法区之前1~5)

![](https://raw.githubusercontent.com/aryangzhu/blogImage/master/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E5%90%84%E4%B8%AA%E7%8E%AF%E8%8A%82.jpeg)

1. 加载:将.class文件通过类加载器加载到内存中
2. 验证:验证魔数、字节码等是否符合规范
3. 准备:将类成员初始化为初始值(final变量除外，final变量直接初始化为变量值)
4. 解析:将常量池中的符号引用替换成直接引用的过程举个例子 hello()方法的地址是123,那么hello()就是符号引用,123就是直接引用
5. 初始化:将定义的static静态方法和变量组织成\<clinit>构造器(也就是3的延伸)
6. 使用:也就是执行创建实例对象的执行顺序
   再来回顾一下,加载实例信息对应的就是上图中的代码块，执行构造方法不必多说
7. 卸载

#### 常量池

JVM中以表的形式存在,JVM文件中

## OOA、OOD&OOP

OOA:面向对象分析
OOD:面向对象设计
OOP:面向对象编程
这节是对前两节内容的强化
问题:为什么static不能访问非static的变量(核心技术卷也没有讲到)

## 继承、封装与多态

对于多态的概念有些生疏,刚好借此几乎复习一下

## 集合

## I/O

### 序列化

将Java对象保存到磁盘
tranisent关键字和Serialiable接口
用途:JSON转换和Tomcat保存Session
