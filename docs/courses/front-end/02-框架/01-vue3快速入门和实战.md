## 简介

## 声明式渲染

reactive,ref主要是这两个

### 声明式&命令式

```html
<script setup>
import { reactive, ref } from 'vue'

const counter = reactive({ count: 0 })
const message = ref('Hello World!')
</script>
```

#### 声明式

关注"是什么"，描述最终要达到的状态或结果

#### 命令式

关注"怎么做"，描述具体的执行步骤和过程

```html
// HTML: <div id="counter">0</div> <button id="btn">点击</button>

let count = 0;
const counterElement = document.getElementById('counter');
const button = document.getElementById('btn');

button.addEventListener('click', () => {
  count++;  // 1. 修改变量
  counterElement.textContent = count;  // 2. 手动更新DOM
});
```

### vue2选项式和vue3组合式

#### 选项式

按照功能类型分组，Mixins(作用域有限)，学习曲线平缓，中小型项目使用多

#### 组织式

按照逻辑功能分组，组合函数(更加灵活)，学习曲线陡峭，大型项目用的比较多

### 响应式&非响应式

响应式是一种编程范式，它允许我们 **声明数据之间的依赖关系** ，当数据变化时，所有依赖它的计算或视图都会**自动、同步地更新**

#### 非响应式

```javascript
// 普通变量
let count = 0;
let double = count * 2; // 此时 double = 0

console.log(double); // 0

// 修改 count
count = 5;
console.log(double); // ❌ 仍然是 0！不会自动更新
```

#### 响应式

```javascript
import { ref, computed } from 'vue';

// 创建响应式数据
const count = ref(0);

// 创建响应式计算属性
const double = computed(() => count.value * 2);

console.log(double.value); // 0

count.value = 5; // 修改原始值
console.log(double.value); // ✅ 自动变成 10！
```

### Attribute绑定

```html
<div v-bind:class="titleClass"></div>
<div :class="titleClass"></div>
```

### 事件监听

```html
<div v-on:click="increment"></div>
<div @click="increment"></div>
```

### 表单绑定

先来看一下如何将一个表单输入元素与响应式变量进行双向绑定，一般是用v-bind和v-on

```html
<input :value="text" @input="onInput">
```

```js
function onInput(e) {
    text.value = e.target.value
}
```

与此同时，Vue提供了一个v-model指令，如下

```html
<input v-model="text" placeholder="Type here">
```

### 条件渲染

使用v-if指令来渲染元素

```html
<template>
    <button @click="toggle">Toggle</button>
    <h1 v-if="awesome">Vue is awesome!</h1>
    <h1 v-else>Oh no</h1>
</template>
```

### 列表渲染

v-for指令来渲染一个基于源数组的列表

```html
<template>
    <form @submit.prevent="addTodo">
	<input v-model="newTodo" required placeholder="new todo">
	<button>Add Todo</button>
    </form>
    <ul>
	<li v-for="todo in todos" :key="todo.id">
	    {{todo.text}}
	    <button @click="removeTodo(todo)"></button>
	</li>
    </ul>
</template>
```

### 计算属性

computed()，它可以让我们创建一个计算属性ref，这个ref会动态地根据其他响应式数据源来就算其.value

```js
const newTodo=ref('')
const hideCompleted=ref(false)
const todos = ref([
    {id:id++, text:'Learn HTML' ,done:true},
    {id:id++, text:'Learn JavaScript', done:true},
    {id:id++, text:'Learn Vue', done:false}
])

const filteredTodos = computed(()=>{
    return hideCompleted.value?todos.value.filter((t)=>!t.done):todos.value
})
```

```html
<template>
  <form @submit.prevent="addTodo">
    <input v-model="newTodo" required placeholder="new todo">
    <button>Add Todo</button>
  </form>
  <ul>
    <li v-for="todo in filteredTodos" :key="todo.id">
      <input type="checkbox" v-model="todo.done">
      <span :class="{ done: todo.done }">{{ todo.text }}</span>
      <button @click="removeTodo(todo)">X</button>
    </li>
  </ul>
  <button @click="hideCompleted = !hideCompleted">
    {{ hideCompleted ? 'Show all' : 'Hide completed' }}
  </button>
</template>
```

### 生命周期和模板引用

```html
<script>
	import {ref,onMounted} from 'vue'

	const pElementRef=ref(null)

	onMounted(()=>{
		pElementRef.value.textContext='mounted!'
	})
</script>
<template>
	<p ref="pElementRef">Hello</p>
</template>
```

官方文档中提及到了挂载的概念，这里说的挂载其实就是将代码转变为可视化页面，不知道为什么要起这么晦涩难懂的名字。

这里面可以看到有两个新的知识点，一个是ref即模板引用(指向模板中一个DOM元素的ref)，通过attribute来实现。

还有一个onMounted函数，就是在挂载完以后立马会执行的方法。

### 侦听器
